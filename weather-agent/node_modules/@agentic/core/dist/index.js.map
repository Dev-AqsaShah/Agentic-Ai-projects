{"version":3,"sources":["../src/parse-structured-output.ts","../src/errors.ts","../src/utils.ts","../src/assert.ts","../src/zod-to-json-schema.ts","../src/schema.ts","../src/create-ai-function.ts","../src/fns.ts","../src/ai-function-set.ts","../src/echo.ts","../src/message.ts"],"sourcesContent":["import type { JsonObject, JsonValue } from 'type-fest'\nimport { jsonrepair, JSONRepairError } from 'jsonrepair'\nimport { z, type ZodType } from 'zod'\nimport { fromZodError } from 'zod-validation-error'\n\nimport { ParseError } from './errors'\nimport { type SafeParseResult } from './types'\n\n/**\n * Parses a string which is expected to contain a structured JSON value.\n *\n * The JSON value is fuzzily parsed in order to support common issues like\n * missing commas, trailing commas, and unquoted keys.\n *\n * The JSON value is then parsed against a `zod` schema to enforce the shape of\n * the output.\n *\n * @returns parsed output\n */\nexport function parseStructuredOutput<T>(\n  value: unknown,\n  outputSchema: ZodType<T>\n): T {\n  if (!value || typeof value !== 'string') {\n    throw new Error('Invalid output: expected string')\n  }\n\n  const output = value as string\n\n  let result\n  if (outputSchema instanceof z.ZodArray || 'element' in outputSchema) {\n    result = parseArrayOutput(output)\n  } else if (outputSchema instanceof z.ZodObject || 'omit' in outputSchema) {\n    result = parseObjectOutput(output)\n  } else if (outputSchema instanceof z.ZodBoolean) {\n    result = parseBooleanOutput(output)\n  } else if (\n    outputSchema instanceof z.ZodNumber ||\n    'nonnegative' in outputSchema\n  ) {\n    result = parseNumberOutput(output, outputSchema as unknown as z.ZodNumber)\n  } else {\n    // Default to string output...\n    result = output\n  }\n\n  // TODO: fix typescript issue here with recursive types\n  const safeResult = (outputSchema.safeParse as any)(result)\n\n  if (!safeResult.success) {\n    throw fromZodError(safeResult.error)\n  }\n\n  return safeResult.data\n}\n\nexport function safeParseStructuredOutput<T>(\n  value: unknown,\n  outputSchema: ZodType<T>\n): SafeParseResult<T> {\n  if (!value || typeof value !== 'string') {\n    return {\n      success: false,\n      error: 'Invalid output: expected string'\n    }\n  }\n\n  const output = value as string\n\n  try {\n    const data = parseStructuredOutput<T>(output, outputSchema)\n    return {\n      success: true,\n      data\n    }\n  } catch (err: any) {\n    // console.error(err)\n\n    return {\n      success: false,\n      error: err.message\n    }\n  }\n}\n\n/**\n * Checks if character at the specified index in a string is escaped.\n *\n * @param str - string to check\n * @param i - index of the character to check\n * @returns whether the character is escaped\n */\nfunction isEscaped(str: string, i: number): boolean {\n  return i > 0 && str[i - 1] === '\\\\' && !(i > 1 && str[i - 2] === '\\\\')\n}\n\n/**\n * Extracts JSON objects or arrays from a string.\n *\n * @param input - string to extract JSON from\n * @param jsonStructureType - type of JSON structure to extract\n * @returns array of extracted JSON objects or arrays\n */\nexport function extractJSONFromString(\n  input: string,\n  jsonStructureType: 'object' | 'array'\n) {\n  const startChar = jsonStructureType === 'object' ? '{' : '['\n  const endChar = jsonStructureType === 'object' ? '}' : ']'\n  const extractedJSONValues: JsonValue[] = []\n  let nestingLevel = 0\n  let startIndex = 0\n  const isInsideQuoted = { '\"': false, \"'\": false }\n\n  for (let i = 0; i < input.length; i++) {\n    const ch = input.charAt(i)\n    switch (ch) {\n      case '\"':\n      case \"'\":\n        if (!isInsideQuoted[ch === '\"' ? \"'\" : '\"'] && !isEscaped(input, i)) {\n          isInsideQuoted[ch] = !isInsideQuoted[ch]\n        }\n\n        break\n\n      default:\n        if (!isInsideQuoted['\"'] && !isInsideQuoted[\"'\"]) {\n          switch (ch) {\n            case startChar:\n              if (nestingLevel === 0) {\n                startIndex = i\n              }\n\n              nestingLevel += 1\n\n              break\n\n            case endChar:\n              nestingLevel -= 1\n              if (nestingLevel === 0) {\n                const candidate = input.slice(startIndex, i + 1)\n                const parsed = JSON.parse(jsonrepair(candidate))\n                if (parsed && typeof parsed === 'object') {\n                  extractedJSONValues.push(parsed as JsonValue)\n                }\n              } else if (nestingLevel < 0) {\n                throw new ParseError(\n                  `Invalid JSON string: unexpected ${endChar} at position ${i}`\n                )\n              }\n          }\n        }\n    }\n  }\n\n  if (nestingLevel !== 0) {\n    throw new ParseError(\n      'Invalid JSON string: unmatched ' + startChar + ' or ' + endChar\n    )\n  }\n\n  return extractedJSONValues\n}\n\nconst BOOLEAN_OUTPUTS: Record<string, boolean> = {\n  true: true,\n  false: false,\n  t: true,\n  f: false,\n  yes: true,\n  no: false,\n  y: true,\n  n: false,\n  '1': true,\n  '0': false\n}\n\n/**\n * Parses an array output from a string.\n *\n * @param output - string to parse\n * @returns parsed array\n */\nexport function parseArrayOutput(output: string): JsonValue[] {\n  try {\n    const arrayOutput = extractJSONFromString(output, 'array')\n    if (arrayOutput.length === 0) {\n      throw new ParseError('Invalid JSON array')\n    }\n\n    const parsedOutput = arrayOutput[0]\n    if (!Array.isArray(parsedOutput)) {\n      throw new ParseError('Expected JSON array')\n    }\n\n    return parsedOutput\n  } catch (err: any) {\n    if (err instanceof JSONRepairError) {\n      throw new ParseError(err.message, { cause: err })\n    } else if (err instanceof SyntaxError) {\n      throw new ParseError(`Invalid JSON array: ${err.message}`, { cause: err })\n    } else {\n      throw err\n    }\n  }\n}\n\n/**\n * Parses an object output from a string.\n *\n * @param output - string to parse\n * @returns parsed object\n */\nexport function parseObjectOutput(output: string): JsonObject {\n  try {\n    const arrayOutput = extractJSONFromString(output, 'object')\n    if (arrayOutput.length === 0) {\n      throw new ParseError('Invalid JSON object')\n    }\n\n    let parsedOutput = arrayOutput[0]\n    if (Array.isArray(parsedOutput)) {\n      // TODO\n      parsedOutput = parsedOutput[0]\n    }\n\n    if (!parsedOutput || typeof parsedOutput !== 'object') {\n      throw new ParseError('Expected JSON object')\n    }\n\n    return parsedOutput as JsonObject\n  } catch (err: any) {\n    if (err instanceof JSONRepairError) {\n      throw new ParseError(err.message, { cause: err })\n    } else if (err instanceof SyntaxError) {\n      throw new ParseError(`Invalid JSON object: ${err.message}`, {\n        cause: err\n      })\n    } else {\n      throw err\n    }\n  }\n}\n\n/**\n * Parses a boolean output from a string.\n *\n * @param output - string to parse\n * @returns parsed boolean\n */\nexport function parseBooleanOutput(output: string): boolean {\n  output = output\n    .toLowerCase()\n    .trim()\n    .replace(/[!.?]+$/, '')\n\n  const booleanOutput = BOOLEAN_OUTPUTS[output]\n\n  if (booleanOutput === undefined) {\n    throw new ParseError(`Invalid boolean output: ${output}`)\n  } else {\n    return booleanOutput\n  }\n}\n\n/**\n * Parses a number output from a string.\n *\n * @param output - string to parse\n * @param outputSchema - zod number schema\n * @returns parsed number\n */\nexport function parseNumberOutput(\n  output: string,\n  outputSchema: z.ZodNumber\n): number {\n  output = output.trim()\n\n  const numberOutput = outputSchema.isInt\n    ? Number.parseInt(output)\n    : Number.parseFloat(output)\n\n  if (Number.isNaN(numberOutput)) {\n    throw new ParseError(`Invalid number output: ${output}`)\n  }\n\n  return numberOutput\n}\n","export class RetryableError extends Error {}\n\nexport class AbortError extends Error {}\n\nexport class ParseError extends RetryableError {}\n\nexport class TimeoutError extends Error {}\n","import dedent from 'dedent'\n\nimport type * as types from './types'\n\nexport { assert } from './assert'\nexport { default as delay } from 'delay'\n\n/**\n * From `inputObj`, create a new object that does not include `keys`.\n *\n * @example\n * ```js\n * omit({ a: 1, b: 2, c: 3 }, 'a', 'c') // { b: 2 }\n * ```\n */\nexport const omit = <\n  T extends Record<string, unknown> | object,\n  K extends keyof any\n>(\n  inputObj: T,\n  ...keys: K[]\n): Omit<T, K> => {\n  const keysSet = new Set(keys)\n  return Object.fromEntries(\n    Object.entries(inputObj).filter(([k]) => !keysSet.has(k as any))\n  ) as any\n}\n\n/**\n * From `inputObj`, create a new object that only includes `keys`.\n *\n * @example\n * ```js\n * pick({ a: 1, b: 2, c: 3 }, 'a', 'c') // { a: 1, c: 3 }\n * ```\n */\nexport const pick = <\n  T extends Record<string, unknown> | object,\n  K extends keyof T\n>(\n  inputObj: T,\n  ...keys: K[]\n): Pick<T, K> => {\n  const keysSet = new Set(keys)\n  return Object.fromEntries(\n    Object.entries(inputObj).filter(([k]) => keysSet.has(k as any))\n  ) as any\n}\n\nexport function pruneUndefined<T extends Record<string, any>>(\n  obj: T\n): NonNullable<{ [K in keyof T]: Exclude<T[K], undefined> }> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => value !== undefined)\n  ) as NonNullable<T>\n}\n\nexport function pruneNullOrUndefined<T extends Record<string, any>>(\n  obj: T\n): NonNullable<{ [K in keyof T]: Exclude<T[K], undefined | null> }> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(\n      ([, value]) => value !== undefined && value !== null\n    )\n  ) as NonNullable<T>\n}\n\nexport function pruneNullOrUndefinedDeep<T extends Record<string, any>>(\n  obj: T\n): NonNullable<{ [K in keyof T]: Exclude<T[K], undefined | null> }> {\n  if (!obj || Array.isArray(obj) || typeof obj !== 'object') return obj\n\n  return Object.fromEntries(\n    Object.entries(obj)\n      .filter(([, value]) => value !== undefined && value !== null)\n      .map(([key, value]) =>\n        Array.isArray(value)\n          ? [\n              key,\n              value\n                .filter((v) => v !== undefined && v !== null)\n                .map(pruneNullOrUndefinedDeep as any)\n            ]\n          : typeof value === 'object'\n            ? [key, pruneNullOrUndefinedDeep(value)]\n            : [key, value]\n      )\n  ) as NonNullable<T>\n}\n\nexport function pruneEmpty<T extends Record<string, any>>(\n  obj: T\n): NonNullable<{ [K in keyof T]: Exclude<T[K], undefined | null> }> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([, value]) => {\n      if (value === undefined || value === null) return false\n      if (typeof value === 'string' && !value) return false\n      if (Array.isArray(value) && !value.length) return false\n      if (\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        !Object.keys(value).length\n      ) {\n        return false\n      }\n\n      return true\n    })\n  ) as NonNullable<T>\n}\n\nexport function pruneEmptyDeep<T>(\n  value?: T\n):\n  | undefined\n  | (T extends Record<string, any>\n      ? { [K in keyof T]: Exclude<T[K], undefined | null> }\n      : T extends Array<infer U>\n        ? Array<Exclude<U, undefined | null>>\n        : Exclude<T, null>) {\n  if (value === undefined || value === null) return undefined\n\n  if (typeof value === 'string') {\n    if (!value) return undefined\n\n    return value as any\n  }\n\n  if (Array.isArray(value)) {\n    if (!value.length) return undefined\n\n    value = value\n      .map((v) => pruneEmptyDeep(v))\n      .filter((v) => v !== undefined) as any\n\n    if (!value || !Array.isArray(value) || !value.length) return undefined\n    return value as any\n  }\n\n  if (typeof value === 'object') {\n    if (!Object.keys(value).length) return undefined\n\n    value = Object.fromEntries(\n      Object.entries(value)\n        .map(([k, v]) => [k, pruneEmptyDeep(v)])\n        .filter(([, v]) => v !== undefined)\n    )\n\n    if (!value || !Object.keys(value).length) return undefined\n    return value as any\n  }\n\n  return value as any\n}\n\nexport function getEnv(name: string): string | undefined {\n  try {\n    return typeof process !== 'undefined'\n      ? // eslint-disable-next-line no-process-env\n        process.env?.[name]\n      : undefined\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Function that does nothing.\n */\nexport const noop = () => undefined\n\n/**\n * Throttles HTTP requests made by a ky instance.\n *\n * Very useful for enforcing rate limits.\n */\nexport function throttleKy(\n  ky: types.KyInstance,\n  throttleFn: <Arguments extends readonly unknown[], ReturnValue>(\n    function_: (...args_: Arguments) => ReturnValue\n  ) => types.ThrottledFunction<(...args_: Arguments) => ReturnValue>\n) {\n  return ky.extend({\n    hooks: {\n      beforeRequest: [throttleFn(noop)]\n    }\n  })\n}\n\n/**\n * Creates a new `URLSearchParams` object with all values coerced to strings\n * that correctly handles arrays of values as repeated keys (or CSV) and\n * correctly removes `undefined` keys and values.\n */\nexport function sanitizeSearchParams(\n  searchParams:\n    | Record<\n        string,\n        string | number | boolean | string[] | number[] | boolean[] | undefined\n      >\n    | object,\n  {\n    csv = false\n  }: {\n    /**\n     * Whether to use comma-separated-values for arrays or multiple entries.\n     *\n     * Defaults to `false` and will use multiple entries.\n     */\n    csv?: boolean\n  } = {}\n): URLSearchParams {\n  const entries = Object.entries(searchParams).flatMap(([key, value]) => {\n    if (key === undefined || value === undefined) {\n      return []\n    }\n\n    if (Array.isArray(value)) {\n      return value.map((v) => [key, String(v)])\n    }\n\n    return [[key, String(value)]]\n  }) as [string, string][]\n\n  if (!csv) {\n    return new URLSearchParams(entries)\n  }\n\n  const csvEntries: Record<string, string> = {}\n  for (const [key, value] of entries) {\n    csvEntries[key] = csvEntries[key] ? `${csvEntries[key]},${value}` : value\n  }\n\n  return new URLSearchParams(csvEntries)\n}\n\n/**\n * Stringifies a JSON value in a way that's optimized for use with LLM prompts.\n *\n * Replacement for `JSON.stringify` when working with LLMs.\n *\n * @example\n * ```ts\n * stringifyForModel({ a: 1, b: 2 }) // '{\"a\":1,\"b\":2}'\n * ```\n */\nexport function stringifyForModel(\n  jsonObject?: types.RelaxedJsonifiable,\n  replacer: (number | string)[] | null = null,\n  space: string | number = 0\n): string {\n  if (jsonObject === undefined) {\n    return ''\n  }\n\n  if (typeof jsonObject === 'string') {\n    return jsonObject\n  }\n\n  return JSON.stringify(jsonObject, replacer, space)\n}\n\nconst dedenter = dedent.withOptions({ escapeSpecialCharacters: true })\n\n/**\n * Cleans a string by removing extra newlines and indentation.\n *\n * @see: https://github.com/dmnd/dedent\n */\nexport function cleanStringForModel(text: string): string {\n  return dedenter(text).trim()\n}\n\nexport function isAIFunction(obj: any): obj is types.AIFunction {\n  if (!obj) return false\n  if (typeof obj !== 'function') return false\n  if (!obj.inputSchema) return false\n  if (!obj.parseInput) return false\n  if (!obj.spec) return false\n  if (!obj.execute) return false\n  if (!obj.spec.name || typeof obj.spec.name !== 'string') return false\n\n  return true\n}\n\nexport function getErrorMessage(error?: unknown): string {\n  if (!error) {\n    return 'unknown error'\n  }\n\n  if (typeof error === 'string') {\n    return error\n  }\n\n  const message = (error as any).message\n  if (message && typeof message === 'string') {\n    return message\n  }\n\n  try {\n    return JSON.stringify(error)\n  } catch {\n    return 'unknown error'\n  }\n}\n\nexport function getShortDateString(date: Date = new Date()): string {\n  return date.toISOString().split('T')[0]!\n}\n","export function assert(\n  value: unknown,\n  message?: string | Error\n): asserts value {\n  if (value) {\n    return\n  }\n\n  if (!message) {\n    throw new Error('Assertion failed')\n  }\n\n  throw typeof message === 'string' ? new Error(message) : message\n}\n","import type { z } from 'zod'\nimport { zodToJsonSchema as zodToJsonSchemaImpl } from 'openai-zod-to-json-schema'\n\nimport type * as types from './types'\nimport { omit } from './utils'\n\n/** Generate a JSON Schema from a Zod schema. */\nexport function zodToJsonSchema(\n  schema: z.ZodType,\n  {\n    strict = false\n  }: {\n    strict?: boolean\n  } = {}\n): types.JSONSchema {\n  return omit(\n    zodToJsonSchemaImpl(schema, {\n      $refStrategy: 'none',\n      openaiStrictMode: strict\n    }),\n    '$schema',\n    'default',\n    'definitions',\n    'description',\n    'markdownDescription'\n  )\n}\n","import type { z } from 'zod'\n\nimport type * as types from './types'\nimport { parseStructuredOutput } from './parse-structured-output'\nimport { stringifyForModel } from './utils'\nimport { zodToJsonSchema } from './zod-to-json-schema'\n\n/**\n * Used to mark schemas so we can support both Zod and custom schemas.\n */\nexport const schemaSymbol = Symbol('agentic.schema')\n\n/**\n * Structured schema used across Agentic, which wraps either a Zod schema or a\n * JSON Schema.\n *\n * JSON Schema support is important to support more dynamic tool sources such as\n * MCP.\n */\nexport type AgenticSchema<TData = unknown> = {\n  /**\n   * The JSON Schema.\n   */\n  readonly jsonSchema: types.JSONSchema\n\n  /**\n   * Parses the value, validates that it matches this schema, and returns a\n   * typed version of the value if it does. Throw an error if the value does\n   * not match the schema.\n   */\n  readonly parse: types.ParseFn<TData>\n\n  /**\n   * Parses the value, validates that it matches this schema, and returns a\n   * typed version of the value if it does. Returns an error message if the\n   * value does not match the schema, and will never throw an error.\n   */\n  readonly safeParse: types.SafeParseFn<TData>\n\n  /**\n   * Used to mark schemas so we can support both Zod and custom schemas.\n   */\n  [schemaSymbol]: true\n\n  /**\n   * Schema type for inference.\n   */\n  _type: TData\n\n  /**\n   * Source Zod schema if this object was created from a Zod schema.\n   */\n  _source?: any\n}\n\nexport function isAgenticSchema(value: unknown): value is AgenticSchema {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    schemaSymbol in value &&\n    value[schemaSymbol] === true &&\n    'jsonSchema' in value &&\n    'parse' in value\n  )\n}\n\nexport function isZodSchema(value: unknown): value is z.ZodType {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    '_def' in value &&\n    '~standard' in value &&\n    (value['~standard'] as any)?.vendor === 'zod'\n  )\n}\n\nexport function asAgenticSchema<TData>(\n  schema: z.Schema<TData> | AgenticSchema<TData>,\n  opts: { strict?: boolean } = {}\n): AgenticSchema<TData> {\n  return isAgenticSchema(schema)\n    ? schema\n    : createAgenticSchemaFromZodSchema(schema, opts)\n}\n\nexport function asZodOrJsonSchema<TData>(\n  schema: z.Schema<TData> | AgenticSchema<TData>\n): z.Schema<TData> | types.JSONSchema {\n  return isZodSchema(schema) ? schema : schema.jsonSchema\n}\n\n/**\n * Create an AgenticSchema from a JSON Schema.\n *\n * All `AIFunction` input schemas accept either a Zod schema or a custom JSON\n * Schema. Use this function to wrap JSON schemas for use with `AIFunction`.\n *\n * Note that JSON Schemas are not validated by default, so you have to pass\n * in an optional `parse` function (using `ajv`, for instance) if you'd like to\n * validate them at runtime.\n */\nexport function createJsonSchema<TData = unknown>(\n  jsonSchema: types.JSONSchema,\n  {\n    parse = (value) => value as TData,\n    safeParse,\n    source\n  }: {\n    parse?: types.ParseFn<TData>\n    safeParse?: types.SafeParseFn<TData>\n    source?: any\n  } = {}\n): AgenticSchema<TData> {\n  safeParse ??= (value: unknown) => {\n    try {\n      const result = parse(value)\n      return { success: true, data: result }\n    } catch (err: any) {\n      return { success: false, error: err.message ?? String(err) }\n    }\n  }\n\n  return {\n    [schemaSymbol]: true,\n    _type: undefined as TData,\n    jsonSchema,\n    parse,\n    safeParse,\n    _source: source\n  }\n}\n\nexport function createAgenticSchemaFromZodSchema<TData>(\n  zodSchema: z.Schema<TData>,\n  opts: { strict?: boolean } = {}\n): AgenticSchema<TData> {\n  return createJsonSchema(zodToJsonSchema(zodSchema, opts), {\n    parse: (value) => {\n      return parseStructuredOutput(value, zodSchema)\n    },\n    source: zodSchema\n  })\n}\n\nconst DEFAULT_SCHEMA_PREFIX = `\n---\n\nRespond with JSON using the following JSON schema:\n\n\\`\\`\\`json`\nconst DEFAULT_SCHEMA_SUFFIX = '```'\n\nexport function augmentSystemMessageWithJsonSchema({\n  schema,\n  system,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}: {\n  schema: types.JSONSchema\n  system?: string\n  schemaPrefix?: string\n  schemaSuffix?: string\n}): string {\n  return [system, schemaPrefix, stringifyForModel(schema), schemaSuffix]\n    .filter(Boolean)\n    .join('\\n')\n    .trim()\n}\n","import type * as types from './types'\nimport { asAgenticSchema } from './schema'\nimport { assert } from './utils'\n\nexport type CreateAIFunctionArgs<\n  InputSchema extends types.AIFunctionInputSchema = types.AIFunctionInputSchema\n> = {\n  /** Name of the function. */\n  name: string\n\n  /** Description of the function. */\n  description: string\n\n  /**\n   * Zod schema or AgenticSchema for the function parameters.\n   *\n   * You can use a JSON Schema for more dynamic tool sources such as MCP by\n   * using the `createJsonSchema` utility function.\n   */\n  inputSchema: InputSchema\n\n  /**\n   * Whether to enable strict structured output generation based on the given\n   * input schema. (this is a feature of the OpenAI API)\n   *\n   * Defaults to `true`.\n   */\n  strict?: boolean\n\n  /**\n   * Optional tags to help organize functions.\n   */\n  tags?: string[]\n}\n\nexport type AIFunctionImplementation<\n  InputSchema extends types.AIFunctionInputSchema,\n  Output\n> = (params: types.inferInput<InputSchema>) => types.MaybePromise<Output>\n\n/**\n * Create a function meant to be used with OpenAI tool or function calling.\n *\n * The returned function will parse the arguments string and call the\n * implementation function with the parsed arguments.\n *\n * The `spec` property of the returned function is the spec for adding the\n * function to the OpenAI API `functions` property.\n */\nexport function createAIFunction<\n  InputSchema extends types.AIFunctionInputSchema,\n  Output\n>(\n  args: CreateAIFunctionArgs<InputSchema>,\n  /** Underlying function implementation. */\n  execute: AIFunctionImplementation<InputSchema, Output>\n): types.AIFunction<InputSchema, Output>\nexport function createAIFunction<\n  InputSchema extends types.AIFunctionInputSchema,\n  Output\n>(\n  args: CreateAIFunctionArgs<InputSchema> & {\n    /** Underlying function implementation. */\n    execute: AIFunctionImplementation<InputSchema, Output>\n  }\n): types.AIFunction<InputSchema, Output>\nexport function createAIFunction<\n  InputSchema extends types.AIFunctionInputSchema,\n  Output\n>(\n  {\n    name,\n    description,\n    inputSchema,\n    strict = true,\n    tags,\n    execute\n  }: CreateAIFunctionArgs<InputSchema> & {\n    /** Underlying function implementation. */\n    execute?: AIFunctionImplementation<InputSchema, Output>\n  },\n  /** Underlying function implementation. */\n  executeArg?: AIFunctionImplementation<InputSchema, Output>\n): types.AIFunction<InputSchema, Output> {\n  assert(name, 'createAIFunction missing required \"name\"')\n  assert(inputSchema, 'createAIFunction missing required \"inputSchema\"')\n  assert(\n    execute || executeArg,\n    'createAIFunction missing required \"execute\" function implementation'\n  )\n  assert(\n    !(execute && executeArg),\n    'createAIFunction: cannot provide both \"execute\" and a second function argument. there should only be one function implementation.'\n  )\n  execute ??= executeArg\n  assert(\n    execute,\n    'createAIFunction missing required \"execute\" function implementation'\n  )\n  assert(\n    typeof execute === 'function',\n    'createAIFunction \"execute\" must be a function'\n  )\n\n  const inputAgenticSchema = asAgenticSchema(inputSchema, { strict })\n\n  /** Parse the arguments string, optionally reading from a message. */\n  const parseInput = (\n    input: string | types.Msg\n  ): types.inferInput<InputSchema> => {\n    if (typeof input === 'string') {\n      return inputAgenticSchema.parse(input)\n    } else {\n      const args = input.function_call?.arguments\n      assert(\n        args,\n        `Missing required function_call.arguments for function ${name}`\n      )\n      return inputAgenticSchema.parse(args)\n    }\n  }\n\n  // Call the underlying function implementation with the parsed arguments.\n  const aiFunction: types.AIFunction<InputSchema, Output> = (\n    input: string | types.Msg\n  ) => {\n    const parsedInput = parseInput(input)\n\n    return execute(parsedInput)\n  }\n\n  // Override the default function name with the intended name.\n  Object.defineProperty(aiFunction, 'name', {\n    value: name,\n    writable: false\n  })\n\n  aiFunction.inputSchema = inputSchema\n  aiFunction.parseInput = parseInput\n  aiFunction.execute = execute\n  aiFunction.tags = tags\n  aiFunction.spec = {\n    name,\n    description,\n    parameters: inputAgenticSchema.jsonSchema,\n    type: 'function',\n    strict\n  }\n\n  return aiFunction\n}\n","import type * as types from './types'\nimport type { AIFunction } from './types'\nimport { AIFunctionSet } from './ai-function-set'\nimport {\n  createAIFunction,\n  type CreateAIFunctionArgs\n} from './create-ai-function'\nimport { assert } from './utils'\n\nexport type PrivateAIFunctionMetadata = CreateAIFunctionArgs & {\n  methodName: string\n}\n\n// Polyfill for `Symbol.metadata`\n// https://github.com/microsoft/TypeScript/issues/53461\ndeclare global {\n  interface SymbolConstructor {\n    readonly metadata: unique symbol\n  }\n}\n\n;(Symbol as any).metadata ??= Symbol.for('Symbol.metadata')\n\nconst _metadata = Object.create(null)\n\nif (typeof Symbol === 'function' && Symbol.metadata) {\n  Object.defineProperty(globalThis, Symbol.metadata, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: _metadata\n  })\n}\n\nexport abstract class AIFunctionsProvider {\n  protected _functions?: AIFunctionSet\n\n  /**\n   * An `AIFunctionSet` containing all of the AI-compatible functions exposed\n   * by this class.\n   *\n   * This property is useful for manipulating AI functions across multiple\n   * sources, picking specific functions, ommitting certain functions, etc.\n   */\n  get functions(): AIFunctionSet {\n    if (!this._functions) {\n      const metadata = this.constructor[Symbol.metadata]\n      assert(\n        metadata,\n        'Your runtime does not appear to support ES decorator metadata: https://github.com/tc39/proposal-decorator-metadata/issues/14'\n      )\n      const invocables =\n        (metadata?.invocables as PrivateAIFunctionMetadata[]) ?? []\n\n      const aiFunctions = invocables.map((invocable) => {\n        const impl = (this as any)[invocable.methodName]\n        assert(impl)\n\n        return createAIFunction(invocable, impl)\n      })\n\n      this._functions = new AIFunctionSet(aiFunctions)\n    }\n\n    return this._functions\n  }\n\n  /**\n   * Returns the AIFunctions provided by this class filtered by the given tags.\n   */\n  getFunctionsFilteredByTags(...tags: string[]): AIFunctionSet {\n    return this.functions.getFilteredByTags(...tags)\n  }\n\n  /**\n   * Returns the AIFunctions provided by this class which match a custom filter\n   * function.\n   */\n  getFunctionsFilteredBy(\n    filterFn: (fn: AIFunction) => boolean | undefined\n  ): AIFunctionSet {\n    return this.functions.getFilteredBy(filterFn)\n  }\n}\n\nexport function aiFunction<\n  This extends AIFunctionsProvider,\n  InputSchema extends types.AIFunctionInputSchema,\n  OptionalArgs extends Array<undefined>,\n  Return extends types.MaybePromise<any>\n>(args: CreateAIFunctionArgs<InputSchema>) {\n  return (\n    _targetMethod: (\n      this: This,\n      input: types.inferInput<InputSchema>,\n      ...optionalArgs: OptionalArgs\n    ) => Return,\n    context: ClassMethodDecoratorContext<\n      This,\n      (\n        this: This,\n        input: types.inferInput<InputSchema>,\n        ...optionalArgs: OptionalArgs\n      ) => Return\n    >\n  ) => {\n    const methodName = String(context.name)\n    if (!context.metadata.invocables) {\n      context.metadata.invocables = []\n    }\n\n    assert(args.name, 'aiFunction requires a non-empty \"name\" argument')\n    ;(context.metadata.invocables as PrivateAIFunctionMetadata[]).push({\n      ...args,\n      methodName\n    })\n\n    context.addInitializer(function () {\n      ;(this as any)[methodName] = (this as any)[methodName].bind(this)\n      // ;(this as any)[methodName].aiFunction = this.functions.get(\n      //   name ?? methodName\n      // )\n    })\n  }\n}\n\n// declare module './fns' {\n//   // Define a type for methods decorated with @aiFunction\n//   type AIFunctionMethod<\n//     T extends z.ZodObject<any> = z.ZodObject<any>,\n//     R = any\n//   > = ((...args: any[]) => R) & {\n//     aiFunction?: AIFunction<T, R>\n//   }\n\n//   interface AIFunctionsProvider {\n//     [methodName: string]: AIFunctionMethod<any, any>\n//   }\n// }\n","import type * as types from './types.ts'\nimport type { AIFunction } from './types.ts'\nimport { AIFunctionsProvider } from './fns'\nimport { isAIFunction } from './utils'\n\nexport type AIFunctionSetOptions = {\n  transformNameKeysFn?: (name: string) => string\n}\n\n/**\n * A set of AI functions intended to make it easier to work with large sets of\n * AI functions across different clients.\n *\n * This class mimics a built-in `Set<AIFunction>`, but with additional utility\n * methods like `pick`, `omit`, and `map`.\n *\n * Function names are case-insensitive to make it easier to match them with\n * possible LLM hallucinations.\n */\nexport class AIFunctionSet implements Iterable<types.AIFunction> {\n  protected readonly _map: Map<string, types.AIFunction>\n  protected readonly _transformNameKeysFn: (name: string) => string\n\n  constructor(\n    aiFunctionLikeObjects?: types.AIFunctionLike[],\n    { transformNameKeysFn = transformName }: AIFunctionSetOptions = {}\n  ) {\n    this._transformNameKeysFn = transformNameKeysFn\n\n    // TODO: these `instanceof` checks seem to be failing on some platforms,\n    // so for now we're using an uglier, but more reliable approach to parsing\n    // the AIFunctionLike objects.\n    const fns = aiFunctionLikeObjects?.flatMap((fn) => {\n      if (fn instanceof AIFunctionsProvider) {\n        return [...fn.functions]\n      }\n\n      if (fn instanceof AIFunctionSet) {\n        return [...fn]\n      }\n\n      if (isAIFunction(fn)) {\n        return fn\n      }\n\n      const fa = ((fn as any).functions ?? fn) as AIFunctionSet\n      if (fa) {\n        try {\n          const fns = [...fa]\n          if (fns.every(isAIFunction)) {\n            return fns\n          }\n        } catch {}\n      }\n\n      throw new Error(`Invalid AIFunctionLike: ${fn}`)\n    })\n\n    // TODO: This is the cleaner approach which should work in theory, but is\n    // not working in practice due to the `instanceof` checks failing.\n    // const fns = aiFunctionLikeObjects?.flatMap((fn) =>\n    //   fn instanceof AIFunctionsProvider\n    //     ? [...fn.functions]\n    //     : fn instanceof AIFunctionSet\n    //       ? [...fn]\n    //       : [fn]\n    // )\n\n    if (fns) {\n      for (const fn of fns) {\n        if (!isAIFunction(fn)) {\n          throw new Error(`Invalid AIFunctionLike: ${fn}`)\n        }\n      }\n    }\n\n    this._map = new Map(\n      fns\n        ? fns.map((fn) => [this._transformNameKeysFn(fn.spec.name), fn])\n        : null\n    )\n  }\n\n  get size(): number {\n    return this._map.size\n  }\n\n  add(fn: types.AIFunction): this {\n    this._map.set(this._transformNameKeysFn(fn.spec.name), fn)\n    return this\n  }\n\n  get(name: string): types.AIFunction | undefined {\n    return this._map.get(this._transformNameKeysFn(name))\n  }\n\n  set(name: string, fn: types.AIFunction): this {\n    this._map.set(this._transformNameKeysFn(name), fn)\n    return this\n  }\n\n  has(name: string): boolean {\n    return this._map.has(this._transformNameKeysFn(name))\n  }\n\n  clear(): void {\n    this._map.clear()\n  }\n\n  delete(name: string): boolean {\n    return this._map.delete(this._transformNameKeysFn(name))\n  }\n\n  pick(...keys: string[]): AIFunctionSet {\n    const keysToIncludeSet = new Set(keys.map(this._transformNameKeysFn))\n    return new AIFunctionSet(\n      Array.from(this).filter((fn) =>\n        keysToIncludeSet.has(this._transformNameKeysFn(fn.spec.name))\n      )\n    )\n  }\n\n  omit(...keys: string[]): AIFunctionSet {\n    const keysToExcludeSet = new Set(keys.map(this._transformNameKeysFn))\n    return new AIFunctionSet(\n      Array.from(this).filter(\n        (fn) => !keysToExcludeSet.has(this._transformNameKeysFn(fn.spec.name))\n      )\n    )\n  }\n\n  map<T>(fn: (fn: types.AIFunction) => T): T[] {\n    return [...this.entries].map(fn)\n  }\n\n  /**\n   * Returns a new AIFunctionSet containing only the AIFunctions in this set\n   * matching the given tags.\n   */\n  getFilteredByTags(...tags: string[]): AIFunctionSet {\n    const tagsSet = new Set(tags)\n    return this.getFilteredBy((fn) => fn.tags?.some((t) => tagsSet.has(t)))\n  }\n\n  /**\n   * Returns a new AIFunctionSet containing only the AIFunctions in this set\n   * matching a custom filter function.\n   */\n  getFilteredBy(\n    filterFn: (fn: AIFunction) => boolean | undefined\n  ): AIFunctionSet {\n    return new AIFunctionSet(Array.from(this).filter((fn) => filterFn(fn)))\n  }\n\n  /**\n   * Returns the functions in this set as an array compatible with OpenAI's\n   * chat completions `functions`.\n   */\n  get specs(): types.AIFunctionSpec[] {\n    return this.map((fn) => fn.spec)\n  }\n\n  /**\n   * Returns the functions in this set as an array compatible with OpenAI's\n   * chat completions `tools`.\n   */\n  get toolSpecs(): types.AIToolSpec[] {\n    return this.map((fn) => ({\n      type: 'function' as const,\n      function: fn.spec\n    }))\n  }\n\n  /**\n   * Returns the tools in this set compatible with OpenAI's `responses` API.\n   *\n   * Note that this is currently the same type as `AIFunctionSet.specs`, but\n   * they are separate APIs which may diverge over time, so if you're using the\n   * OpenAI `responses` API, you should reference this property.\n   */\n  get responsesToolSpecs(): types.AIFunctionSpec[] {\n    return this.specs\n  }\n\n  get entries(): IterableIterator<types.AIFunction> {\n    return this._map.values()\n  }\n\n  [Symbol.iterator](): Iterator<types.AIFunction> {\n    return this.entries\n  }\n}\n\nfunction transformName(name: string): string {\n  // TODO: decamalize?\n  return name.toLowerCase()\n}\n","import { z } from 'zod'\n\nimport { createAIFunction } from './create-ai-function'\nimport { aiFunction, AIFunctionsProvider } from './fns'\n\n/**\n * Test AI tool with one function `echo`, which echoes the input.\n */\nexport class EchoAITool extends AIFunctionsProvider {\n  @aiFunction({\n    name: 'echo',\n    description: 'Echoes the input.',\n    inputSchema: z.object({\n      query: z.string().describe('input query to echo')\n    })\n  })\n  async echo({ query }: { query: string }) {\n    return query\n  }\n}\n\n/**\n * Test AI function `echo`, which echoes the input.\n */\nexport const echoAIFunction = createAIFunction(\n  {\n    name: 'echo',\n    description: 'Echoes the input.',\n    inputSchema: z.object({\n      query: z.string().describe('input query to echo')\n    })\n  },\n  ({ query }: { query: string }) => {\n    return query\n  }\n)\n","import type { Jsonifiable } from 'type-fest'\n\nimport { cleanStringForModel, stringifyForModel } from './utils'\n\n/**\n * Generic/default OpenAI message without any narrowing applied.\n */\nexport interface Msg {\n  /**\n   * The role of the messages author. One of `system`, `user`, `assistant`,\n   * 'tool', or `function`.\n   */\n  role: Msg.Role\n\n  /**\n   * The contents of the message. `content` may be null for assistant messages\n   * with function calls or `undefined` for assistant messages if a `refusal`\n   * was given by the model.\n   */\n  content?: string | null\n\n  /**\n   * The reason the model refused to generate this message or `undefined` if the\n   * message was generated successfully.\n   */\n  refusal?: string | null\n\n  /**\n   * The name and arguments of a function that should be called, as generated\n   * by the model.\n   */\n  function_call?: Msg.Call.Function\n\n  /**\n   * The tool calls generated by the model, such as function calls.\n   */\n  tool_calls?: Msg.Call.Tool[]\n\n  /**\n   * Tool call that this message is responding to.\n   */\n  tool_call_id?: string\n\n  /**\n   * The name of the author of this message. `name` is required if role is\n   * `function`, and it should be the name of the function whose response is in the\n   * `content`. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of\n   * 64 characters.\n   */\n  name?: string\n}\n\nexport interface LegacyMsg {\n  content: string | null\n  role: Msg.Role\n  function_call?: Msg.Call.Function\n  tool_calls?: Msg.Call.Tool[]\n  tool_call_id?: string\n  name?: string\n}\n\n/** Used for multimodal chat messages. */\nexport type ChatMessageContentPart =\n  | {\n      type: 'text'\n      text: string\n    }\n  // User messages only.\n  | {\n      type: 'image_url'\n      image_url: {\n        url: string\n        detail?: 'low' | 'high' | 'auto' | (string & {})\n      }\n    }\n  | {\n      type: 'input_audio'\n      input_audio: {\n        data: string\n        format: 'mp3' | 'wav' | (string & {})\n      }\n    }\n  // Assistant messages only.\n  | {\n      type: 'refusal'\n      refusal: string\n    }\n\n/** Narrowed OpenAI Message types. */\nexport namespace Msg {\n  /** Possible roles for a message. */\n  export type Role =\n    | 'system'\n    | 'developer'\n    | 'user'\n    | 'assistant'\n    | 'function'\n    | 'tool'\n\n  export namespace Call {\n    /**\n     * The name and arguments of a function that should be called, as generated\n     * by the model.\n     */\n    export type Function = {\n      /**\n       * The arguments to call the function with, as generated by the model in\n       * JSON format.\n       */\n      arguments: string\n\n      /** The name of the function to call. */\n      name: string\n    }\n\n    /** The tool calls generated by the model, such as function calls. */\n    export type Tool = {\n      /** The ID of the tool call. */\n      id: string\n\n      /** The type of the tool. Currently, only `function` is supported. */\n      type: 'function'\n\n      /** The function that the model called. */\n      function: Call.Function\n    }\n  }\n\n  /** Message with text content for the system. */\n  export type System = {\n    role: 'system'\n    content: string\n    name?: string\n  }\n\n  /** Message with text content for the developer. */\n  export type Developer = {\n    role: 'developer'\n    content: string\n    name?: string\n  }\n\n  /** Message with text content from the user. */\n  export type User = {\n    role: 'user'\n    name?: string\n    content: string\n  }\n\n  /** Message with text content from the assistant. */\n  export type Assistant = {\n    role: 'assistant'\n    name?: string\n    content: string\n  }\n\n  /** Message with refusal reason from the assistant. */\n  export type Refusal = {\n    role: 'assistant'\n    name?: string\n    refusal: string\n  }\n\n  /** Message with arguments to call a function. */\n  export type FuncCall = {\n    role: 'assistant'\n    name?: string\n    content: null\n    function_call: Call.Function\n  }\n\n  /** Message with the result of a function call. */\n  export type FuncResult = {\n    role: 'function'\n    name: string\n    content: string\n  }\n\n  /** Message with arguments to call one or more tools. */\n  export type ToolCall = {\n    role: 'assistant'\n    name?: string\n    content: null\n    tool_calls: Call.Tool[]\n  }\n\n  /** Message with the result of a tool call. */\n  export type ToolResult = {\n    role: 'tool'\n    tool_call_id: string\n    content: string\n  }\n}\n\n/** Utility functions for creating and checking message types. */\nexport namespace Msg {\n  /** Create a system message. Cleans indentation and newlines by default. */\n  export function system(\n    content: string,\n    opts?: {\n      /** Custom name for the message. */\n      name?: string\n      /** Whether to clean extra newlines and indentation. Defaults to true. */\n      cleanContent?: boolean\n    }\n  ): Msg.System {\n    const { name, cleanContent = true } = opts ?? {}\n    return {\n      role: 'system',\n      content: cleanContent ? cleanStringForModel(content) : content,\n      ...(name ? { name } : {})\n    }\n  }\n\n  /** Create a developer message. Cleans indentation and newlines by default. */\n  export function developer(\n    content: string,\n    opts?: {\n      /** Custom name for the message. */\n      name?: string\n      /** Whether to clean extra newlines and indentation. Defaults to true. */\n      cleanContent?: boolean\n    }\n  ): Msg.Developer {\n    const { name, cleanContent = true } = opts ?? {}\n    return {\n      role: 'developer',\n      content: cleanContent ? cleanStringForModel(content) : content,\n      ...(name ? { name } : {})\n    }\n  }\n\n  /** Create a user message. Cleans indentation and newlines by default. */\n  export function user(\n    content: string,\n    opts?: {\n      /** Custom name for the message. */\n      name?: string\n      /** Whether to clean extra newlines and indentation. Defaults to true. */\n      cleanContent?: boolean\n    }\n  ): Msg.User {\n    const { name, cleanContent = true } = opts ?? {}\n    return {\n      role: 'user',\n      content: cleanContent ? cleanStringForModel(content) : content,\n      ...(name ? { name } : {})\n    }\n  }\n\n  /** Create an assistant message. Cleans indentation and newlines by default. */\n  export function assistant(\n    content: string,\n    opts?: {\n      /** Custom name for the message. */\n      name?: string\n      /** Whether to clean extra newlines and indentation. Defaults to true. */\n      cleanContent?: boolean\n    }\n  ): Msg.Assistant {\n    const { name, cleanContent = true } = opts ?? {}\n    return {\n      role: 'assistant',\n      content: cleanContent ? cleanStringForModel(content) : content,\n      ...(name ? { name } : {})\n    }\n  }\n\n  /**\n   * Create an assistant refusal message. Cleans indentation and newlines by\n   * default.\n   */\n  export function refusal(\n    refusal: string,\n    opts?: {\n      /** Custom name for the message. */\n      name?: string\n      /** Whether to clean extra newlines and indentation. Defaults to true. */\n      cleanRefusal?: boolean\n    }\n  ): Msg.Refusal {\n    const { name, cleanRefusal = true } = opts ?? {}\n    return {\n      role: 'assistant',\n      refusal: cleanRefusal ? cleanStringForModel(refusal) : refusal,\n      ...(name ? { name } : {})\n    }\n  }\n\n  /** Create a function call message with argumets. */\n  export function funcCall(\n    funcCall: {\n      /** Name of the function to call. */\n      name: string\n      /** Arguments to pass to the function. */\n      arguments: string\n    },\n    opts?: {\n      /** The name descriptor for the message.(message.name) */\n      name?: string\n    }\n  ): Msg.FuncCall {\n    return {\n      ...opts,\n      role: 'assistant',\n      content: null,\n      function_call: funcCall\n    }\n  }\n\n  /** Create a function result message. */\n  export function funcResult(\n    content: Jsonifiable,\n    name: string\n  ): Msg.FuncResult {\n    const contentString = stringifyForModel(content)\n    return { role: 'function', content: contentString, name }\n  }\n\n  /** Create a function call message with argumets. */\n  export function toolCall(\n    toolCalls: Msg.Call.Tool[],\n    opts?: {\n      /** The name descriptor for the message.(message.name) */\n      name?: string\n    }\n  ): Msg.ToolCall {\n    return {\n      ...opts,\n      role: 'assistant',\n      content: null,\n      tool_calls: toolCalls\n    }\n  }\n\n  /** Create a tool call result message. */\n  export function toolResult(\n    content: Jsonifiable,\n    toolCallId: string,\n    opts?: {\n      /** The name of the tool which was called */\n      name?: string\n    }\n  ): Msg.ToolResult {\n    const contentString = stringifyForModel(content)\n    return {\n      ...opts,\n      role: 'tool',\n      tool_call_id: toolCallId,\n      content: contentString\n    }\n  }\n\n  /** Get the narrowed message from an EnrichedResponse. */\n  export function getMessage(\n    // @TODO\n    response: any\n    // response: ChatModel.EnrichedResponse\n  ): Msg.Assistant | Msg.Refusal | Msg.FuncCall | Msg.ToolCall {\n    const msg = response.choices[0].message as Msg\n    return narrowResponseMessage(msg)\n  }\n\n  /** Narrow a message received from the API. It only responds with role=assistant */\n  export function narrowResponseMessage(\n    msg: Msg\n  ): Msg.Assistant | Msg.Refusal | Msg.FuncCall | Msg.ToolCall {\n    if (msg.content === null && msg.tool_calls != null) {\n      return Msg.toolCall(msg.tool_calls)\n    } else if (msg.content === null && msg.function_call != null) {\n      return Msg.funcCall(msg.function_call)\n    } else if (msg.content !== null && msg.content !== undefined) {\n      return Msg.assistant(msg.content)\n    } else if (msg.refusal != null) {\n      return Msg.refusal(msg.refusal)\n    } else {\n      // @TODO: probably don't want to error here\n      console.log('Invalid message', msg)\n      throw new Error('Invalid message')\n    }\n  }\n\n  /** Check if a message is a system message. */\n  export function isSystem(message: Msg): message is Msg.System {\n    return message.role === 'system'\n  }\n  /** Check if a message is a developer message. */\n  export function isDeveloper(message: Msg): message is Msg.Developer {\n    return message.role === 'developer'\n  }\n  /** Check if a message is a user message. */\n  export function isUser(message: Msg): message is Msg.User {\n    return message.role === 'user'\n  }\n  /** Check if a message is an assistant message. */\n  export function isAssistant(message: Msg): message is Msg.Assistant {\n    return message.role === 'assistant' && message.content != null\n  }\n  /** Check if a message is an assistant refusal message. */\n  export function isRefusal(message: Msg): message is Msg.Refusal {\n    return message.role === 'assistant' && message.refusal !== null\n  }\n  /** Check if a message is a function call message with arguments. */\n  export function isFuncCall(message: Msg): message is Msg.FuncCall {\n    return message.role === 'assistant' && message.function_call != null\n  }\n  /** Check if a message is a function result message. */\n  export function isFuncResult(message: Msg): message is Msg.FuncResult {\n    return message.role === 'function' && message.name != null\n  }\n  /** Check if a message is a tool calls message. */\n  export function isToolCall(message: Msg): message is Msg.ToolCall {\n    return message.role === 'assistant' && message.tool_calls != null\n  }\n  /** Check if a message is a tool call result message. */\n  export function isToolResult(message: Msg): message is Msg.ToolResult {\n    return message.role === 'tool' && !!message.tool_call_id\n  }\n\n  /** Narrow a ChatModel.Message to a specific type. */\n  export function narrow(message: Msg.System): Msg.System\n  export function narrow(message: Msg.Developer): Msg.Developer\n  export function narrow(message: Msg.User): Msg.User\n  export function narrow(message: Msg.Assistant): Msg.Assistant\n  export function narrow(message: Msg.Assistant): Msg.Refusal\n  export function narrow(message: Msg.FuncCall): Msg.FuncCall\n  export function narrow(message: Msg.FuncResult): Msg.FuncResult\n  export function narrow(message: Msg.ToolCall): Msg.ToolCall\n  export function narrow(message: Msg.ToolResult): Msg.ToolResult\n  export function narrow(\n    message: Msg\n  ):\n    | Msg.System\n    | Msg.Developer\n    | Msg.User\n    | Msg.Assistant\n    | Msg.Refusal\n    | Msg.FuncCall\n    | Msg.FuncResult\n    | Msg.ToolCall\n    | Msg.ToolResult {\n    if (isSystem(message)) {\n      return message\n    }\n    if (isDeveloper(message)) {\n      return message\n    }\n    if (isUser(message)) {\n      return message\n    }\n    if (isAssistant(message)) {\n      return message\n    }\n    if (isRefusal(message)) {\n      return message\n    }\n    if (isFuncCall(message)) {\n      return message\n    }\n    if (isFuncResult(message)) {\n      return message\n    }\n    if (isToolCall(message)) {\n      return message\n    }\n    if (isToolResult(message)) {\n      return message\n    }\n    throw new Error('Invalid message type')\n  }\n}\n"],"mappings":"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","names":["default","aiFunction","fns","z","z","Msg","refusal","funcCall"]}