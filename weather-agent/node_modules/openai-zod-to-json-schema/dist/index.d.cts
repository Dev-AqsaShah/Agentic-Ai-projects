import { ZodArrayDef, ZodBigIntDef, ZodNumberDef, ZodDateDef, ZodEnumDef, ZodIntersectionDef, ZodLiteralDef, ZodStringDef, ZodRecordDef, ZodTypeAny, ZodMapDef, ZodNativeEnumDef, ZodNullableDef, ZodObjectDef, ZodSetDef, ZodTupleDef, ZodTupleItems, ZodUnionDef, ZodDiscriminatedUnionDef, ZodTypeDef, ZodSchema, ZodBrandedDef, ZodCatchDef, ZodDefaultDef, ZodEffectsDef, ZodOptionalDef, ZodPipelineDef, ZodPromiseDef, ZodReadonlyDef } from 'zod';

type JsonSchema7AnyType = {};
declare function parseAnyDef(): JsonSchema7AnyType;

type ErrorMessages<T extends JsonSchema7TypeUnion, OmitProperties extends string = ''> = Partial<Omit<{
    [key in keyof T]: string;
}, OmitProperties | 'type' | 'errorMessages'>>;
declare function addErrorMessage<T extends {
    errorMessage?: ErrorMessages<any>;
}>(res: T, key: keyof T, errorMessage: string | undefined, refs: Refs): void;
declare function setResponseValueAndErrors<Json7Type extends JsonSchema7TypeUnion & {
    errorMessage?: ErrorMessages<Json7Type>;
}, Key extends keyof Omit<Json7Type, 'errorMessage'>>(res: Json7Type, key: Key, value: Json7Type[Key], errorMessage: string | undefined, refs: Refs): void;

type JsonSchema7ArrayType = {
    type: 'array';
    items?: JsonSchema7Type | undefined;
    minItems?: number;
    maxItems?: number;
    errorMessages?: ErrorMessages<JsonSchema7ArrayType, 'items'>;
};
declare function parseArrayDef(def: ZodArrayDef, refs: Refs): JsonSchema7ArrayType;

type JsonSchema7BigintType = {
    type: 'integer';
    format: 'int64';
    minimum?: BigInt;
    exclusiveMinimum?: BigInt;
    maximum?: BigInt;
    exclusiveMaximum?: BigInt;
    multipleOf?: BigInt;
    errorMessage?: ErrorMessages<JsonSchema7BigintType>;
};
declare function parseBigintDef(def: ZodBigIntDef, refs: Refs): JsonSchema7BigintType;

type JsonSchema7BooleanType = {
    type: 'boolean';
};
declare function parseBooleanDef(): JsonSchema7BooleanType;

type JsonSchema7NumberType = {
    type: 'number' | 'integer';
    minimum?: number;
    exclusiveMinimum?: number;
    maximum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    errorMessage?: ErrorMessages<JsonSchema7NumberType>;
};
declare function parseNumberDef(def: ZodNumberDef, refs: Refs): JsonSchema7NumberType;

type JsonSchema7DateType = {
    type: 'integer' | 'string';
    format: 'unix-time' | 'date-time' | 'date';
    minimum?: number;
    maximum?: number;
    errorMessage?: ErrorMessages<JsonSchema7NumberType>;
} | {
    anyOf: JsonSchema7DateType[];
};
declare function parseDateDef(def: ZodDateDef, refs: Refs, overrideDateStrategy?: DateStrategy): JsonSchema7DateType;

type JsonSchema7EnumType = {
    type: 'string';
    enum: string[];
};
declare function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType;

type JsonSchema7AllOfType = {
    allOf: JsonSchema7Type[];
    unevaluatedProperties?: boolean;
};
declare function parseIntersectionDef(def: ZodIntersectionDef, refs: Refs): JsonSchema7AllOfType | JsonSchema7Type | undefined;

type JsonSchema7LiteralType = {
    type: 'string' | 'number' | 'integer' | 'boolean';
    const: string | number | boolean;
} | {
    type: 'object' | 'array';
};
declare function parseLiteralDef(def: ZodLiteralDef, refs: Refs): JsonSchema7LiteralType;

/**
 * Generated from the regular expressions found here as of 2024-05-22:
 * https://github.com/colinhacks/zod/blob/master/src/types.ts.
 *
 * Expressions with /i flag have been changed accordingly.
 */
declare const zodPatterns: {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    readonly cuid: RegExp;
    readonly cuid2: RegExp;
    readonly ulid: RegExp;
    /**
     * `a-z` was added to replicate /i flag
     */
    readonly email: RegExp;
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    readonly emoji: () => RegExp;
    /**
     * Unused
     */
    readonly uuid: RegExp;
    /**
     * Unused
     */
    readonly ipv4: RegExp;
    /**
     * Unused
     */
    readonly ipv6: RegExp;
    readonly base64: RegExp;
    readonly nanoid: RegExp;
};
type JsonSchema7StringType = {
    type: 'string';
    minLength?: number;
    maxLength?: number;
    format?: 'email' | 'idn-email' | 'uri' | 'uuid' | 'date-time' | 'ipv4' | 'ipv6' | 'date' | 'time' | 'duration';
    pattern?: string;
    allOf?: {
        pattern: string;
        errorMessage?: ErrorMessages<{
            pattern: string;
        }>;
    }[];
    anyOf?: {
        format: string;
        errorMessage?: ErrorMessages<{
            format: string;
        }>;
    }[];
    errorMessage?: ErrorMessages<JsonSchema7StringType>;
    contentEncoding?: string;
};
declare function parseStringDef(def: ZodStringDef, refs: Refs): JsonSchema7StringType;

type JsonSchema7RecordPropertyNamesType = Omit<JsonSchema7StringType, 'type'> | Omit<JsonSchema7EnumType, 'type'>;
type JsonSchema7RecordType = {
    type: 'object';
    additionalProperties: JsonSchema7Type;
    propertyNames?: JsonSchema7RecordPropertyNamesType;
};
declare function parseRecordDef(def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef, refs: Refs): JsonSchema7RecordType;

type JsonSchema7MapType = {
    type: 'array';
    maxItems: 125;
    items: {
        type: 'array';
        items: [JsonSchema7Type, JsonSchema7Type];
        minItems: 2;
        maxItems: 2;
    };
};
declare function parseMapDef(def: ZodMapDef, refs: Refs): JsonSchema7MapType | JsonSchema7RecordType;

type JsonSchema7NativeEnumType = {
    type: 'string' | 'number' | ['string', 'number'];
    enum: (string | number)[];
};
declare function parseNativeEnumDef(def: ZodNativeEnumDef): JsonSchema7NativeEnumType;

type JsonSchema7NeverType = {
    not: {};
};
declare function parseNeverDef(): JsonSchema7NeverType;

type JsonSchema7NullType = {
    type: 'null';
};
declare function parseNullDef(refs: Refs): JsonSchema7NullType;

type JsonSchema7NullableType = {
    anyOf: [JsonSchema7Type, JsonSchema7NullType];
} | {
    type: [string, 'null'];
};
declare function parseNullableDef(def: ZodNullableDef, refs: Refs): JsonSchema7NullableType | undefined;

type JsonSchema7ObjectType = {
    type: 'object';
    properties: Record<string, JsonSchema7Type>;
    additionalProperties: boolean | JsonSchema7Type;
    required?: string[];
};
declare function parseObjectDef(def: ZodObjectDef, refs: Refs): JsonSchema7ObjectType;

type JsonSchema7SetType = {
    type: 'array';
    uniqueItems: true;
    items?: JsonSchema7Type | undefined;
    minItems?: number;
    maxItems?: number;
    errorMessage?: ErrorMessages<JsonSchema7SetType>;
};
declare function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType;

type JsonSchema7TupleType = {
    type: 'array';
    minItems: number;
    items: JsonSchema7Type[];
} & ({
    maxItems: number;
} | {
    additionalItems?: JsonSchema7Type | undefined;
});
declare function parseTupleDef(def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>, refs: Refs): JsonSchema7TupleType;

type JsonSchema7UndefinedType = {
    not: {};
};
declare function parseUndefinedDef(): JsonSchema7UndefinedType;

declare const primitiveMappings: {
    readonly ZodString: "string";
    readonly ZodNumber: "number";
    readonly ZodBigInt: "integer";
    readonly ZodBoolean: "boolean";
    readonly ZodNull: "null";
};
type JsonSchema7Primitive = (typeof primitiveMappings)[keyof typeof primitiveMappings];
type JsonSchema7UnionType = JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType;
type JsonSchema7PrimitiveUnionType = {
    type: JsonSchema7Primitive | JsonSchema7Primitive[];
} | {
    type: JsonSchema7Primitive | JsonSchema7Primitive[];
    enum: (string | number | bigint | boolean | null)[];
};
type JsonSchema7AnyOfType = {
    anyOf: JsonSchema7Type[];
};
declare function parseUnionDef(def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>, refs: Refs): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined;

type JsonSchema7UnknownType = {};
declare function parseUnknownDef(): JsonSchema7UnknownType;

type JsonSchema7RefType = {
    $ref: string;
};
type JsonSchema7Meta = {
    title?: string;
    default?: any;
    description?: string;
    markdownDescription?: string;
};
type JsonSchema7TypeUnion = JsonSchema7StringType | JsonSchema7ArrayType | JsonSchema7NumberType | JsonSchema7BigintType | JsonSchema7BooleanType | JsonSchema7DateType | JsonSchema7EnumType | JsonSchema7LiteralType | JsonSchema7NativeEnumType | JsonSchema7NullType | JsonSchema7NumberType | JsonSchema7ObjectType | JsonSchema7RecordType | JsonSchema7TupleType | JsonSchema7UnionType | JsonSchema7UndefinedType | JsonSchema7RefType | JsonSchema7NeverType | JsonSchema7MapType | JsonSchema7AnyType | JsonSchema7NullableType | JsonSchema7AllOfType | JsonSchema7UnknownType | JsonSchema7SetType;
type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;
declare function parseDef(def: ZodTypeDef, refs: Refs, forceResolution?: boolean): JsonSchema7Type | undefined;

type Refs = {
    seen: Map<ZodTypeDef, Seen>;
    /**
     * Set of all the `$ref`s we created, e.g. `Set(['#/$defs/ui'])`
     * this notable does not include any `definitions` that were
     * explicitly given as an option.
     */
    seenRefs: Set<string>;
    currentPath: string[];
    propertyPath: string[] | undefined;
} & Options<Targets>;
type Seen = {
    def: ZodTypeDef;
    path: string[];
    jsonSchema: JsonSchema7Type | undefined;
};
declare const getRefs: (options?: string | Partial<Options<Targets>>) => Refs;

type Targets = 'jsonSchema7' | 'jsonSchema2019-09' | 'openApi3';
type DateStrategy = 'format:date-time' | 'format:date' | 'string' | 'integer';
declare const ignoreOverride: unique symbol;
type Options<Target extends Targets = 'jsonSchema7'> = {
    name: string | undefined;
    $refStrategy: 'root' | 'relative' | 'none' | 'seen' | 'extract-to-root';
    basePath: string[];
    effectStrategy: 'input' | 'any';
    pipeStrategy: 'input' | 'output' | 'all';
    dateStrategy: DateStrategy | DateStrategy[];
    mapStrategy: 'entries' | 'record';
    removeAdditionalStrategy: 'passthrough' | 'strict';
    nullableStrategy: 'from-target' | 'property';
    target: Target;
    strictUnions: boolean;
    definitionPath: string;
    definitions: Record<string, ZodSchema | ZodTypeDef>;
    errorMessages: boolean;
    markdownDescription: boolean;
    patternStrategy: 'escape' | 'preserve';
    applyRegexFlags: boolean;
    emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';
    base64Strategy: 'format:binary' | 'contentEncoding:base64' | 'pattern:zod';
    nameStrategy: 'ref' | 'duplicate-ref' | 'title';
    override?: (def: ZodTypeDef, refs: Refs, seen: Seen | undefined, forceResolution?: boolean) => JsonSchema7Type | undefined | typeof ignoreOverride;
    openaiStrictMode?: boolean;
};
declare const getDefaultOptions: <Target extends Targets>(options: Partial<Options<Target>> | string | undefined) => Options<Target>;

declare function parseBrandedDef(_def: ZodBrandedDef<any>, refs: Refs): JsonSchema7Type | undefined;

declare const parseCatchDef: (def: ZodCatchDef<any>, refs: Refs) => JsonSchema7Type | undefined;

declare function parseDefaultDef(_def: ZodDefaultDef, refs: Refs): JsonSchema7Type & {
    default: any;
};

declare function parseEffectsDef(_def: ZodEffectsDef, refs: Refs, forceResolution: boolean): JsonSchema7Type | undefined;

declare const parseOptionalDef: (def: ZodOptionalDef, refs: Refs) => JsonSchema7Type | undefined;

declare const parsePipelineDef: (def: ZodPipelineDef<any, any>, refs: Refs) => JsonSchema7AllOfType | JsonSchema7Type | undefined;

declare function parsePromiseDef(def: ZodPromiseDef, refs: Refs): JsonSchema7Type | undefined;

declare const parseReadonlyDef: (def: ZodReadonlyDef<any>, refs: Refs) => JsonSchema7Type | undefined;

declare const zodToJsonSchema: <Target extends Targets = "jsonSchema7">(schema: ZodSchema<any>, options?: Partial<Options<Target>> | string) => (Target extends "jsonSchema7" ? JsonSchema7Type : object) & {
    $schema?: string;
    definitions?: {
        [key: string]: Target extends "jsonSchema7" ? JsonSchema7Type : Target extends "jsonSchema2019-09" ? JsonSchema7Type : object;
    };
};

export { type DateStrategy, type ErrorMessages, type JsonSchema7AllOfType, type JsonSchema7AnyType, type JsonSchema7ArrayType, type JsonSchema7BigintType, type JsonSchema7BooleanType, type JsonSchema7DateType, type JsonSchema7EnumType, type JsonSchema7LiteralType, type JsonSchema7MapType, type JsonSchema7NativeEnumType, type JsonSchema7NeverType, type JsonSchema7NullType, type JsonSchema7NullableType, type JsonSchema7NumberType, type JsonSchema7ObjectType, type JsonSchema7RecordType, type JsonSchema7SetType, type JsonSchema7StringType, type JsonSchema7TupleType, type JsonSchema7Type, type JsonSchema7TypeUnion, type JsonSchema7UndefinedType, type JsonSchema7UnionType, type JsonSchema7UnknownType, type Options, type Refs, type Seen, type Targets, addErrorMessage, getDefaultOptions, getRefs, ignoreOverride, parseAnyDef, parseArrayDef, parseBigintDef, parseBooleanDef, parseBrandedDef, parseCatchDef, parseDateDef, parseDef, parseDefaultDef, parseEffectsDef, parseEnumDef, parseIntersectionDef, parseLiteralDef, parseMapDef, parseNativeEnumDef, parseNeverDef, parseNullDef, parseNullableDef, parseNumberDef, parseObjectDef, parseOptionalDef, parsePipelineDef, parsePromiseDef, parseReadonlyDef, parseRecordDef, parseSetDef, parseStringDef, parseTupleDef, parseUndefinedDef, parseUnionDef, parseUnknownDef, primitiveMappings, setResponseValueAndErrors, zodPatterns, zodToJsonSchema };
