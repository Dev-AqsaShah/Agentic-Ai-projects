{"version":3,"sources":["../src/index.ts","../src/vendor/zod-to-json-schema/Options.ts","../src/vendor/zod-to-json-schema/util.ts","../src/vendor/zod-to-json-schema/Refs.ts","../src/vendor/zod-to-json-schema/errorMessages.ts","../src/vendor/zod-to-json-schema/parseDef.ts","../src/vendor/zod-to-json-schema/parsers/any.ts","../src/vendor/zod-to-json-schema/parsers/array.ts","../src/vendor/zod-to-json-schema/parsers/bigint.ts","../src/vendor/zod-to-json-schema/parsers/boolean.ts","../src/vendor/zod-to-json-schema/parsers/branded.ts","../src/vendor/zod-to-json-schema/parsers/catch.ts","../src/vendor/zod-to-json-schema/parsers/date.ts","../src/vendor/zod-to-json-schema/parsers/default.ts","../src/vendor/zod-to-json-schema/parsers/effects.ts","../src/vendor/zod-to-json-schema/parsers/enum.ts","../src/vendor/zod-to-json-schema/parsers/intersection.ts","../src/vendor/zod-to-json-schema/parsers/literal.ts","../src/vendor/zod-to-json-schema/parsers/record.ts","../src/vendor/zod-to-json-schema/parsers/string.ts","../src/vendor/zod-to-json-schema/parsers/map.ts","../src/vendor/zod-to-json-schema/parsers/nativeEnum.ts","../src/vendor/zod-to-json-schema/parsers/never.ts","../src/vendor/zod-to-json-schema/parsers/null.ts","../src/vendor/zod-to-json-schema/parsers/union.ts","../src/vendor/zod-to-json-schema/parsers/nullable.ts","../src/vendor/zod-to-json-schema/parsers/number.ts","../src/vendor/zod-to-json-schema/parsers/object.ts","../src/vendor/zod-to-json-schema/parsers/optional.ts","../src/vendor/zod-to-json-schema/parsers/pipeline.ts","../src/vendor/zod-to-json-schema/parsers/promise.ts","../src/vendor/zod-to-json-schema/parsers/set.ts","../src/vendor/zod-to-json-schema/parsers/tuple.ts","../src/vendor/zod-to-json-schema/parsers/undefined.ts","../src/vendor/zod-to-json-schema/parsers/unknown.ts","../src/vendor/zod-to-json-schema/parsers/readonly.ts","../src/vendor/zod-to-json-schema/zodToJsonSchema.ts"],"sourcesContent":["export * from './vendor/zod-to-json-schema'\n","import { ZodSchema, ZodTypeDef } from 'zod';\nimport { Refs, Seen } from './Refs';\nimport { JsonSchema7Type } from './parseDef';\n\nexport type Targets = 'jsonSchema7' | 'jsonSchema2019-09' | 'openApi3';\n\nexport type DateStrategy = 'format:date-time' | 'format:date' | 'string' | 'integer';\n\nexport const ignoreOverride = Symbol('Let zodToJsonSchema decide on which parser to use');\n\nexport type Options<Target extends Targets = 'jsonSchema7'> = {\n  name: string | undefined;\n  $refStrategy: 'root' | 'relative' | 'none' | 'seen' | 'extract-to-root';\n  basePath: string[];\n  effectStrategy: 'input' | 'any';\n  pipeStrategy: 'input' | 'output' | 'all';\n  dateStrategy: DateStrategy | DateStrategy[];\n  mapStrategy: 'entries' | 'record';\n  removeAdditionalStrategy: 'passthrough' | 'strict';\n  nullableStrategy: 'from-target' | 'property';\n  target: Target;\n  strictUnions: boolean;\n  definitionPath: string;\n  definitions: Record<string, ZodSchema | ZodTypeDef>;\n  errorMessages: boolean;\n  markdownDescription: boolean;\n  patternStrategy: 'escape' | 'preserve';\n  applyRegexFlags: boolean;\n  emailStrategy: 'format:email' | 'format:idn-email' | 'pattern:zod';\n  base64Strategy: 'format:binary' | 'contentEncoding:base64' | 'pattern:zod';\n  nameStrategy: 'ref' | 'duplicate-ref' | 'title';\n  override?: (\n    def: ZodTypeDef,\n    refs: Refs,\n    seen: Seen | undefined,\n    forceResolution?: boolean,\n  ) => JsonSchema7Type | undefined | typeof ignoreOverride;\n  openaiStrictMode?: boolean;\n};\n\nconst defaultOptions: Omit<Options, 'definitions' | 'basePath'> = {\n  name: undefined,\n  $refStrategy: 'root',\n  effectStrategy: 'input',\n  pipeStrategy: 'all',\n  dateStrategy: 'format:date-time',\n  mapStrategy: 'entries',\n  nullableStrategy: 'from-target',\n  removeAdditionalStrategy: 'passthrough',\n  definitionPath: 'definitions',\n  target: 'jsonSchema7',\n  strictUnions: false,\n  errorMessages: false,\n  markdownDescription: false,\n  patternStrategy: 'escape',\n  applyRegexFlags: false,\n  emailStrategy: 'format:email',\n  base64Strategy: 'contentEncoding:base64',\n  nameStrategy: 'ref',\n};\n\nexport const getDefaultOptions = <Target extends Targets>(\n  options: Partial<Options<Target>> | string | undefined,\n) => {\n  // We need to add `definitions` here as we may mutate it\n  return (\n    typeof options === 'string' ?\n      {\n        ...defaultOptions,\n        basePath: ['#'],\n        definitions: {},\n        name: options,\n      }\n    : {\n        ...defaultOptions,\n        basePath: ['#'],\n        definitions: {},\n        ...options,\n      }) as Options<Target>;\n};\n","import type { ZodSchema, ZodTypeDef } from 'zod';\n\nexport const zodDef = (zodSchema: ZodSchema | ZodTypeDef): ZodTypeDef => {\n  return '_def' in zodSchema ? zodSchema._def : zodSchema;\n};\n\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n","import type { ZodTypeDef } from 'zod';\nimport { getDefaultOptions, Options, Targets } from './Options';\nimport { JsonSchema7Type } from './parseDef';\nimport { zodDef } from './util';\n\nexport type Refs = {\n  seen: Map<ZodTypeDef, Seen>;\n  /**\n   * Set of all the `$ref`s we created, e.g. `Set(['#/$defs/ui'])`\n   * this notable does not include any `definitions` that were\n   * explicitly given as an option.\n   */\n  seenRefs: Set<string>;\n  currentPath: string[];\n  propertyPath: string[] | undefined;\n} & Options<Targets>;\n\nexport type Seen = {\n  def: ZodTypeDef;\n  path: string[];\n  jsonSchema: JsonSchema7Type | undefined;\n};\n\nexport const getRefs = (options?: string | Partial<Options<Targets>>): Refs => {\n  const _options = getDefaultOptions(options);\n  const currentPath =\n    _options.name !== undefined ?\n      [..._options.basePath, _options.definitionPath, _options.name]\n    : _options.basePath;\n  return {\n    ..._options,\n    currentPath: currentPath,\n    propertyPath: undefined,\n    seenRefs: new Set(),\n    seen: new Map(\n      Object.entries(_options.definitions).map(([name, def]) => [\n        zodDef(def),\n        {\n          def: zodDef(def),\n          path: [..._options.basePath, _options.definitionPath, name],\n          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n          jsonSchema: undefined,\n        },\n      ]),\n    ),\n  };\n};\n","import { JsonSchema7TypeUnion } from './parseDef';\nimport { Refs } from './Refs';\n\nexport type ErrorMessages<T extends JsonSchema7TypeUnion, OmitProperties extends string = ''> = Partial<\n  Omit<{ [key in keyof T]: string }, OmitProperties | 'type' | 'errorMessages'>\n>;\n\nexport function addErrorMessage<T extends { errorMessage?: ErrorMessages<any> }>(\n  res: T,\n  key: keyof T,\n  errorMessage: string | undefined,\n  refs: Refs,\n) {\n  if (!refs?.errorMessages) return;\n  if (errorMessage) {\n    res.errorMessage = {\n      ...res.errorMessage,\n      [key]: errorMessage,\n    };\n  }\n}\n\nexport function setResponseValueAndErrors<\n  Json7Type extends JsonSchema7TypeUnion & {\n    errorMessage?: ErrorMessages<Json7Type>;\n  },\n  Key extends keyof Omit<Json7Type, 'errorMessage'>,\n>(res: Json7Type, key: Key, value: Json7Type[Key], errorMessage: string | undefined, refs: Refs) {\n  res[key] = value;\n  addErrorMessage(res, key, errorMessage, refs);\n}\n","import { ZodFirstPartyTypeKind, ZodTypeDef } from 'zod';\nimport { JsonSchema7AnyType, parseAnyDef } from './parsers/any';\nimport { JsonSchema7ArrayType, parseArrayDef } from './parsers/array';\nimport { JsonSchema7BigintType, parseBigintDef } from './parsers/bigint';\nimport { JsonSchema7BooleanType, parseBooleanDef } from './parsers/boolean';\nimport { parseBrandedDef } from './parsers/branded';\nimport { parseCatchDef } from './parsers/catch';\nimport { JsonSchema7DateType, parseDateDef } from './parsers/date';\nimport { parseDefaultDef } from './parsers/default';\nimport { parseEffectsDef } from './parsers/effects';\nimport { JsonSchema7EnumType, parseEnumDef } from './parsers/enum';\nimport { JsonSchema7AllOfType, parseIntersectionDef } from './parsers/intersection';\nimport { JsonSchema7LiteralType, parseLiteralDef } from './parsers/literal';\nimport { JsonSchema7MapType, parseMapDef } from './parsers/map';\nimport { JsonSchema7NativeEnumType, parseNativeEnumDef } from './parsers/nativeEnum';\nimport { JsonSchema7NeverType, parseNeverDef } from './parsers/never';\nimport { JsonSchema7NullType, parseNullDef } from './parsers/null';\nimport { JsonSchema7NullableType, parseNullableDef } from './parsers/nullable';\nimport { JsonSchema7NumberType, parseNumberDef } from './parsers/number';\nimport { JsonSchema7ObjectType, parseObjectDef } from './parsers/object';\nimport { parseOptionalDef } from './parsers/optional';\nimport { parsePipelineDef } from './parsers/pipeline';\nimport { parsePromiseDef } from './parsers/promise';\nimport { JsonSchema7RecordType, parseRecordDef } from './parsers/record';\nimport { JsonSchema7SetType, parseSetDef } from './parsers/set';\nimport { JsonSchema7StringType, parseStringDef } from './parsers/string';\nimport { JsonSchema7TupleType, parseTupleDef } from './parsers/tuple';\nimport { JsonSchema7UndefinedType, parseUndefinedDef } from './parsers/undefined';\nimport { JsonSchema7UnionType, parseUnionDef } from './parsers/union';\nimport { JsonSchema7UnknownType, parseUnknownDef } from './parsers/unknown';\nimport { Refs, Seen } from './Refs';\nimport { parseReadonlyDef } from './parsers/readonly';\nimport { ignoreOverride } from './Options';\n\ntype JsonSchema7RefType = { $ref: string };\ntype JsonSchema7Meta = {\n  title?: string;\n  default?: any;\n  description?: string;\n  markdownDescription?: string;\n};\n\nexport type JsonSchema7TypeUnion =\n  | JsonSchema7StringType\n  | JsonSchema7ArrayType\n  | JsonSchema7NumberType\n  | JsonSchema7BigintType\n  | JsonSchema7BooleanType\n  | JsonSchema7DateType\n  | JsonSchema7EnumType\n  | JsonSchema7LiteralType\n  | JsonSchema7NativeEnumType\n  | JsonSchema7NullType\n  | JsonSchema7NumberType\n  | JsonSchema7ObjectType\n  | JsonSchema7RecordType\n  | JsonSchema7TupleType\n  | JsonSchema7UnionType\n  | JsonSchema7UndefinedType\n  | JsonSchema7RefType\n  | JsonSchema7NeverType\n  | JsonSchema7MapType\n  | JsonSchema7AnyType\n  | JsonSchema7NullableType\n  | JsonSchema7AllOfType\n  | JsonSchema7UnknownType\n  | JsonSchema7SetType;\n\nexport type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false, // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      if ('$ref' in seenSchema) {\n        refs.seenRefs.add(seenSchema.$ref);\n      }\n\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchema = selectParser(def, (def as any).typeName, refs, forceResolution);\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs,\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case 'root':\n      return { $ref: item.path.join('/') };\n    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.\n    // the top-level schema *must* be `{\"type\": \"object\", \"properties\": {...}}` but if we ever\n    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract\n    // the schema to `#/definitions/` and reference that.\n    //\n    // e.g. if we need to reference a schema at\n    // `[\"#\",\"definitions\",\"contactPerson\",\"properties\",\"person1\",\"properties\",\"name\"]`\n    // then we'll extract it out to `contactPerson_properties_person1_properties_name`\n    case 'extract-to-root':\n      const name = item.path.slice(refs.basePath.length + 1).join('_');\n\n      // we don't need to extract the root schema in this case, as it's already\n      // been added to the definitions\n      if (name !== refs.name && refs.nameStrategy === 'duplicate-ref') {\n        refs.definitions[name] = item.def;\n      }\n\n      return { $ref: [...refs.basePath, refs.definitionPath, name].join('/') };\n    case 'relative':\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case 'none':\n    case 'seen': {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(`Recursive reference detected at ${refs.currentPath.join('/')}! Defaulting to any`);\n\n        return {};\n      }\n\n      return refs.$refStrategy === 'seen' ? {} : undefined;\n    }\n  }\n};\n\nconst getRelativePath = (pathA: string[], pathB: string[]) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');\n};\n\nconst selectParser = (\n  def: any,\n  typeName: ZodFirstPartyTypeKind,\n  refs: Refs,\n  forceResolution: boolean,\n): JsonSchema7Type | undefined => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return parseDef(def.getter()._def, refs);\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs, forceResolution);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      return ((_: never) => undefined)(typeName);\n  }\n};\n\nconst addMeta = (def: ZodTypeDef, refs: Refs, jsonSchema: JsonSchema7Type): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};\n","export type JsonSchema7AnyType = {};\n\nexport function parseAnyDef(): JsonSchema7AnyType {\n  return {};\n}\n","import { ZodArrayDef, ZodFirstPartyTypeKind } from 'zod';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport type JsonSchema7ArrayType = {\n  type: 'array';\n  items?: JsonSchema7Type | undefined;\n  minItems?: number;\n  maxItems?: number;\n  errorMessages?: ErrorMessages<JsonSchema7ArrayType, 'items'>;\n};\n\nexport function parseArrayDef(def: ZodArrayDef, refs: Refs) {\n  const res: JsonSchema7ArrayType = {\n    type: 'array',\n  };\n  if (def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items'],\n    });\n  }\n\n  if (def.minLength) {\n    setResponseValueAndErrors(res, 'minItems', def.minLength.value, def.minLength.message, refs);\n  }\n  if (def.maxLength) {\n    setResponseValueAndErrors(res, 'maxItems', def.maxLength.value, def.maxLength.message, refs);\n  }\n  if (def.exactLength) {\n    setResponseValueAndErrors(res, 'minItems', def.exactLength.value, def.exactLength.message, refs);\n    setResponseValueAndErrors(res, 'maxItems', def.exactLength.value, def.exactLength.message, refs);\n  }\n  return res;\n}\n","import { ZodBigIntDef } from 'zod';\nimport { Refs } from '../Refs';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\n\nexport type JsonSchema7BigintType = {\n  type: 'integer';\n  format: 'int64';\n  minimum?: BigInt;\n  exclusiveMinimum?: BigInt;\n  maximum?: BigInt;\n  exclusiveMaximum?: BigInt;\n  multipleOf?: BigInt;\n  errorMessage?: ErrorMessages<JsonSchema7BigintType>;\n};\n\nexport function parseBigintDef(def: ZodBigIntDef, refs: Refs): JsonSchema7BigintType {\n  const res: JsonSchema7BigintType = {\n    type: 'integer',\n    format: 'int64',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        if (refs.target === 'jsonSchema7') {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, 'minimum', check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, 'exclusiveMinimum', check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true as any;\n          }\n          setResponseValueAndErrors(res, 'minimum', check.value, check.message, refs);\n        }\n        break;\n      case 'max':\n        if (refs.target === 'jsonSchema7') {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, 'maximum', check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, 'exclusiveMaximum', check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true as any;\n          }\n          setResponseValueAndErrors(res, 'maximum', check.value, check.message, refs);\n        }\n        break;\n      case 'multipleOf':\n        setResponseValueAndErrors(res, 'multipleOf', check.value, check.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n","export type JsonSchema7BooleanType = {\n  type: 'boolean';\n};\n\nexport function parseBooleanDef(): JsonSchema7BooleanType {\n  return {\n    type: 'boolean',\n  };\n}\n","import { ZodBrandedDef } from 'zod';\nimport { parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport function parseBrandedDef(_def: ZodBrandedDef<any>, refs: Refs) {\n  return parseDef(_def.type._def, refs);\n}\n","import { ZodCatchDef } from 'zod';\nimport { parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport const parseCatchDef = (def: ZodCatchDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n","import { ZodDateDef } from 'zod';\nimport { Refs } from '../Refs';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { JsonSchema7NumberType } from './number';\nimport { DateStrategy } from '../Options';\n\nexport type JsonSchema7DateType =\n  | {\n      type: 'integer' | 'string';\n      format: 'unix-time' | 'date-time' | 'date';\n      minimum?: number;\n      maximum?: number;\n      errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n    }\n  | {\n      anyOf: JsonSchema7DateType[];\n    };\n\nexport function parseDateDef(\n  def: ZodDateDef,\n  refs: Refs,\n  overrideDateStrategy?: DateStrategy,\n): JsonSchema7DateType {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n    };\n  }\n\n  switch (strategy) {\n    case 'string':\n    case 'format:date-time':\n      return {\n        type: 'string',\n        format: 'date-time',\n      };\n    case 'format:date':\n      return {\n        type: 'string',\n        format: 'date',\n      };\n    case 'integer':\n      return integerDateParser(def, refs);\n  }\n}\n\nconst integerDateParser = (def: ZodDateDef, refs: Refs) => {\n  const res: JsonSchema7DateType = {\n    type: 'integer',\n    format: 'unix-time',\n  };\n\n  if (refs.target === 'openApi3') {\n    return res;\n  }\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'min':\n        setResponseValueAndErrors(\n          res,\n          'minimum',\n          check.value, // This is in milliseconds\n          check.message,\n          refs,\n        );\n        break;\n      case 'max':\n        setResponseValueAndErrors(\n          res,\n          'maximum',\n          check.value, // This is in milliseconds\n          check.message,\n          refs,\n        );\n        break;\n    }\n  }\n\n  return res;\n};\n","import { ZodDefaultDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport function parseDefaultDef(_def: ZodDefaultDef, refs: Refs): JsonSchema7Type & { default: any } {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue(),\n  };\n}\n","import { ZodEffectsDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport function parseEffectsDef(\n  _def: ZodEffectsDef,\n  refs: Refs,\n  forceResolution: boolean,\n): JsonSchema7Type | undefined {\n  return refs.effectStrategy === 'input' ? parseDef(_def.schema._def, refs, forceResolution) : {};\n}\n","import { ZodEnumDef } from 'zod';\n\nexport type JsonSchema7EnumType = {\n  type: 'string';\n  enum: string[];\n};\n\nexport function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType {\n  return {\n    type: 'string',\n    enum: [...def.values],\n  };\n}\n","import { ZodIntersectionDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7StringType } from './string';\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType,\n): type is JsonSchema7AllOfType => {\n  if ('type' in type && type.type === 'string') return false;\n  return 'allOf' in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '0'],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '1'],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  let unevaluatedProperties: Pick<JsonSchema7AllOfType, 'unevaluatedProperties'> | undefined =\n    refs.target === 'jsonSchema2019-09' ? { unevaluatedProperties: false } : undefined;\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if ('additionalProperties' in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ?\n      {\n        allOf: mergedAllOf,\n        ...unevaluatedProperties,\n      }\n    : undefined;\n}\n","import { ZodLiteralDef } from 'zod';\nimport { Refs } from '../Refs';\n\nexport type JsonSchema7LiteralType =\n  | {\n      type: 'string' | 'number' | 'integer' | 'boolean';\n      const: string | number | boolean;\n    }\n  | {\n      type: 'object' | 'array';\n    };\n\nexport function parseLiteralDef(def: ZodLiteralDef, refs: Refs): JsonSchema7LiteralType {\n  const parsedType = typeof def.value;\n  if (\n    parsedType !== 'bigint' &&\n    parsedType !== 'number' &&\n    parsedType !== 'boolean' &&\n    parsedType !== 'string'\n  ) {\n    return {\n      type: Array.isArray(def.value) ? 'array' : 'object',\n    };\n  }\n\n  if (refs.target === 'openApi3') {\n    return {\n      type: parsedType === 'bigint' ? 'integer' : parsedType,\n      enum: [def.value],\n    } as any;\n  }\n\n  return {\n    type: parsedType === 'bigint' ? 'integer' : parsedType,\n    const: def.value,\n  };\n}\n","import { ZodFirstPartyTypeKind, ZodMapDef, ZodRecordDef, ZodTypeAny } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7EnumType } from './enum';\nimport { JsonSchema7ObjectType } from './object';\nimport { JsonSchema7StringType, parseStringDef } from './string';\n\ntype JsonSchema7RecordPropertyNamesType =\n  | Omit<JsonSchema7StringType, 'type'>\n  | Omit<JsonSchema7EnumType, 'type'>;\n\nexport type JsonSchema7RecordType = {\n  type: 'object';\n  additionalProperties: JsonSchema7Type;\n  propertyNames?: JsonSchema7RecordPropertyNamesType;\n};\n\nexport function parseRecordDef(\n  def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef,\n  refs: Refs,\n): JsonSchema7RecordType {\n  if (refs.target === 'openApi3' && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      type: 'object',\n      required: def.keyType._def.values,\n      properties: def.keyType._def.values.reduce(\n        (acc: Record<string, JsonSchema7Type>, key: string) => ({\n          ...acc,\n          [key]:\n            parseDef(def.valueType._def, {\n              ...refs,\n              currentPath: [...refs.currentPath, 'properties', key],\n            }) ?? {},\n        }),\n        {},\n      ),\n      additionalProperties: false,\n    } satisfies JsonSchema7ObjectType as any;\n  }\n\n  const schema: JsonSchema7RecordType = {\n    type: 'object',\n    additionalProperties:\n      parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalProperties'],\n      }) ?? {},\n  };\n\n  if (refs.target === 'openApi3') {\n    return schema;\n  }\n\n  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {\n    const keyType: JsonSchema7RecordPropertyNamesType = Object.entries(\n      parseStringDef(def.keyType._def, refs),\n    ).reduce((acc, [key, value]) => (key === 'type' ? acc : { ...acc, [key]: value }), {});\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values,\n      },\n    };\n  }\n\n  return schema;\n}\n","// @ts-nocheck\nimport { ZodStringDef } from 'zod';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { Refs } from '../Refs';\n\nlet emojiRegex: RegExp | undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp('^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$', 'u');\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: 'string';\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | 'email'\n    | 'idn-email'\n    | 'uri'\n    | 'uuid'\n    | 'date-time'\n    | 'ipv4'\n    | 'ipv6'\n    | 'date'\n    | 'time'\n    | 'duration';\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n    errorMessage?: ErrorMessages<{ pattern: string }>;\n  }[];\n  anyOf?: {\n    format: string;\n    errorMessage?: ErrorMessages<{ format: string }>;\n  }[];\n  errorMessage?: ErrorMessages<JsonSchema7StringType>;\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(def: ZodStringDef, refs: Refs): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: 'string',\n  };\n\n  function processPattern(value: string): string {\n    return refs.patternStrategy === 'escape' ? escapeNonAlphaNumeric(value) : value;\n  }\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case 'min':\n          setResponseValueAndErrors(\n            res,\n            'minLength',\n            typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          break;\n        case 'max':\n          setResponseValueAndErrors(\n            res,\n            'maxLength',\n            typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n\n          break;\n        case 'email':\n          switch (refs.emailStrategy) {\n            case 'format:email':\n              addFormat(res, 'email', check.message, refs);\n              break;\n            case 'format:idn-email':\n              addFormat(res, 'idn-email', check.message, refs);\n              break;\n            case 'pattern:zod':\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case 'url':\n          addFormat(res, 'uri', check.message, refs);\n          break;\n        case 'uuid':\n          addFormat(res, 'uuid', check.message, refs);\n          break;\n        case 'regex':\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case 'cuid':\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case 'cuid2':\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case 'startsWith':\n          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n          break;\n        case 'endsWith':\n          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n          break;\n\n        case 'datetime':\n          addFormat(res, 'date-time', check.message, refs);\n          break;\n        case 'date':\n          addFormat(res, 'date', check.message, refs);\n          break;\n        case 'time':\n          addFormat(res, 'time', check.message, refs);\n          break;\n        case 'duration':\n          addFormat(res, 'duration', check.message, refs);\n          break;\n        case 'length':\n          setResponseValueAndErrors(\n            res,\n            'minLength',\n            typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          setResponseValueAndErrors(\n            res,\n            'maxLength',\n            typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          break;\n        case 'includes': {\n          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n          break;\n        }\n        case 'ip': {\n          if (check.version !== 'v6') {\n            addFormat(res, 'ipv4', check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addFormat(res, 'ipv6', check.message, refs);\n          }\n          break;\n        }\n        case 'emoji':\n          addPattern(res, zodPatterns.emoji, check.message, refs);\n          break;\n        case 'ulid': {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case 'base64': {\n          switch (refs.base64Strategy) {\n            case 'format:binary': {\n              addFormat(res, 'binary' as any, check.message, refs);\n              break;\n            }\n\n            case 'contentEncoding:base64': {\n              setResponseValueAndErrors(res, 'contentEncoding', 'base64', check.message, refs);\n              break;\n            }\n\n            case 'pattern:zod': {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case 'nanoid': {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          break;\n        default:\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nconst escapeNonAlphaNumeric = (value: string) =>\n  Array.from(value)\n    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n    .join('');\n\nconst addFormat = (\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>['format'],\n  message: string | undefined,\n  refs: Refs,\n) => {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { format: schema.errorMessage.format },\n          }),\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message && refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'format', value, message, refs);\n  }\n};\n\nconst addPattern = (\n  schema: JsonSchema7StringType,\n  regex: RegExp | (() => RegExp),\n  message: string | undefined,\n  refs: Refs,\n) => {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { pattern: schema.errorMessage.pattern },\n          }),\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.allOf!.push({\n      pattern: processRegExp(regex, refs),\n      ...(message && refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'pattern', processRegExp(regex, refs), message, refs);\n  }\n};\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nconst processRegExp = (regexOrFunction: RegExp | (() => RegExp), refs: Refs): string => {\n  const regex = typeof regexOrFunction === 'function' ? regexOrFunction() : regexOrFunction;\n  if (!refs.applyRegexFlags || !regex.flags) return regex.source;\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes('i'), // Case-insensitive\n    m: regex.flags.includes('m'), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes('s'), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = '';\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === '^') {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === '$') {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === '.') {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === '\\\\') {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === ']') {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === '[') {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    const regexTest = new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        '/',\n      )} to a flag-independent form! Falling back to the flag-ignorant source`,\n    );\n    return regex.source;\n  }\n\n  return pattern;\n};\n","import { ZodMapDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7RecordType, parseRecordDef } from './record';\n\nexport type JsonSchema7MapType = {\n  type: 'array';\n  maxItems: 125;\n  items: {\n    type: 'array';\n    items: [JsonSchema7Type, JsonSchema7Type];\n    minItems: 2;\n    maxItems: 2;\n  };\n};\n\nexport function parseMapDef(def: ZodMapDef, refs: Refs): JsonSchema7MapType | JsonSchema7RecordType {\n  if (refs.mapStrategy === 'record') {\n    return parseRecordDef(def, refs);\n  }\n\n  const keys =\n    parseDef(def.keyType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '0'],\n    }) || {};\n  const values =\n    parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'items', 'items', '1'],\n    }) || {};\n  return {\n    type: 'array',\n    maxItems: 125,\n    items: {\n      type: 'array',\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2,\n    },\n  };\n}\n","import { ZodNativeEnumDef } from 'zod';\n\nexport type JsonSchema7NativeEnumType = {\n  type: 'string' | 'number' | ['string', 'number'];\n  enum: (string | number)[];\n};\n\nexport function parseNativeEnumDef(def: ZodNativeEnumDef): JsonSchema7NativeEnumType {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key: string) => {\n    return typeof object[object[key]!] !== 'number';\n  });\n\n  const actualValues = actualKeys.map((key: string) => object[key]!);\n\n  const parsedTypes = Array.from(new Set(actualValues.map((values: string | number) => typeof values)));\n\n  return {\n    type:\n      parsedTypes.length === 1 ?\n        parsedTypes[0] === 'string' ?\n          'string'\n        : 'number'\n      : ['string', 'number'],\n    enum: actualValues,\n  };\n}\n","export type JsonSchema7NeverType = {\n  not: {};\n};\n\nexport function parseNeverDef(): JsonSchema7NeverType {\n  return {\n    not: {},\n  };\n}\n","import { Refs } from '../Refs';\n\nexport type JsonSchema7NullType = {\n  type: 'null';\n};\n\nexport function parseNullDef(refs: Refs): JsonSchema7NullType {\n  return refs.target === 'openApi3' ?\n      ({\n        enum: ['null'],\n        nullable: true,\n      } as any)\n    : {\n        type: 'null',\n      };\n}\n","import { ZodDiscriminatedUnionDef, ZodLiteralDef, ZodTypeAny, ZodUnionDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport const primitiveMappings = {\n  ZodString: 'string',\n  ZodNumber: 'number',\n  ZodBigInt: 'integer',\n  ZodBoolean: 'boolean',\n  ZodNull: 'null',\n} as const;\ntype ZodPrimitive = keyof typeof primitiveMappings;\ntype JsonSchema7Primitive = (typeof primitiveMappings)[keyof typeof primitiveMappings];\n\nexport type JsonSchema7UnionType = JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType;\n\ntype JsonSchema7PrimitiveUnionType =\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n    }\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n      enum: (string | number | bigint | boolean | null)[];\n    };\n\ntype JsonSchema7AnyOfType = {\n  anyOf: JsonSchema7Type[];\n};\n\nexport function parseUnionDef(\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined {\n  if (refs.target === 'openApi3') return asAnyOf(def, refs);\n\n  const options: readonly ZodTypeAny[] =\n    def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (\n    options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))\n  ) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n\n    const types = options.reduce((types: JsonSchema7Primitive[], x) => {\n      const type = primitiveMappings[x._def.typeName as ZodPrimitive]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n\n    return {\n      type: types.length > 1 ? types : types[0]!,\n    };\n  } else if (options.every((x) => x._def.typeName === 'ZodLiteral' && !x.description)) {\n    // all options literals\n\n    const types = options.reduce((acc: JsonSchema7Primitive[], x: { _def: ZodLiteralDef }) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          return [...acc, type];\n        case 'bigint':\n          return [...acc, 'integer' as const];\n        case 'object':\n          if (x._def.value === null) return [...acc, 'null' as const];\n        case 'symbol':\n        case 'undefined':\n        case 'function':\n        default:\n          return acc;\n      }\n    }, []);\n\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0]!,\n        enum: options.reduce(\n          (acc, x) => {\n            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n          },\n          [] as (string | number | bigint | boolean | null)[],\n        ),\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === 'ZodEnum')) {\n    return {\n      type: 'string',\n      enum: options.reduce(\n        (acc: string[], x) => [...acc, ...x._def.values.filter((x: string) => !acc.includes(x))],\n        [],\n      ),\n    };\n  }\n\n  return asAnyOf(def, refs);\n}\n\nconst asAnyOf = (\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs,\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined => {\n  const anyOf = ((def.options instanceof Map ? Array.from(def.options.values()) : def.options) as any[])\n    .map((x, i) =>\n      parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'anyOf', `${i}`],\n      }),\n    )\n    .filter(\n      (x): x is JsonSchema7Type =>\n        !!x && (!refs.strictUnions || (typeof x === 'object' && Object.keys(x).length > 0)),\n    );\n\n  return anyOf.length ? { anyOf } : undefined;\n};\n","import { ZodNullableDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7NullType } from './null';\nimport { primitiveMappings } from './union';\n\nexport type JsonSchema7NullableType =\n  | {\n      anyOf: [JsonSchema7Type, JsonSchema7NullType];\n    }\n  | {\n      type: [string, 'null'];\n    };\n\nexport function parseNullableDef(def: ZodNullableDef, refs: Refs): JsonSchema7NullableType | undefined {\n  if (\n    ['ZodString', 'ZodNumber', 'ZodBigInt', 'ZodBoolean', 'ZodNull'].includes(def.innerType._def.typeName) &&\n    (!def.innerType._def.checks || !def.innerType._def.checks.length)\n  ) {\n    if (refs.target === 'openApi3' || refs.nullableStrategy === 'property') {\n      return {\n        type: primitiveMappings[def.innerType._def.typeName as keyof typeof primitiveMappings],\n        nullable: true,\n      } as any;\n    }\n\n    return {\n      type: [primitiveMappings[def.innerType._def.typeName as keyof typeof primitiveMappings], 'null'],\n    };\n  }\n\n  if (refs.target === 'openApi3') {\n    const base = parseDef(def.innerType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath],\n    });\n\n    if (base && '$ref' in base) return { allOf: [base], nullable: true } as any;\n\n    return base && ({ ...base, nullable: true } as any);\n  }\n\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '0'],\n  });\n\n  return base && { anyOf: [base, { type: 'null' }] };\n}\n","import { ZodNumberDef } from 'zod';\nimport { addErrorMessage, ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { Refs } from '../Refs';\n\nexport type JsonSchema7NumberType = {\n  type: 'number' | 'integer';\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n  errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n};\n\nexport function parseNumberDef(def: ZodNumberDef, refs: Refs): JsonSchema7NumberType {\n  const res: JsonSchema7NumberType = {\n    type: 'number',\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case 'int':\n        res.type = 'integer';\n        addErrorMessage(res, 'type', check.message, refs);\n        break;\n      case 'min':\n        if (refs.target === 'jsonSchema7') {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, 'minimum', check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, 'exclusiveMinimum', check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true as any;\n          }\n          setResponseValueAndErrors(res, 'minimum', check.value, check.message, refs);\n        }\n        break;\n      case 'max':\n        if (refs.target === 'jsonSchema7') {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, 'maximum', check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, 'exclusiveMaximum', check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true as any;\n          }\n          setResponseValueAndErrors(res, 'maximum', check.value, check.message, refs);\n        }\n        break;\n      case 'multipleOf':\n        setResponseValueAndErrors(res, 'multipleOf', check.value, check.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n","import { ZodObjectDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nfunction decideAdditionalProperties(def: ZodObjectDef, refs: Refs) {\n  if (refs.removeAdditionalStrategy === 'strict') {\n    return def.catchall._def.typeName === 'ZodNever' ?\n        def.unknownKeys !== 'strict'\n      : parseDef(def.catchall._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, 'additionalProperties'],\n        }) ?? true;\n  } else {\n    return def.catchall._def.typeName === 'ZodNever' ?\n        def.unknownKeys === 'passthrough'\n      : parseDef(def.catchall._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, 'additionalProperties'],\n        }) ?? true;\n  }\n}\n\nexport type JsonSchema7ObjectType = {\n  type: 'object';\n  properties: Record<string, JsonSchema7Type>;\n  additionalProperties: boolean | JsonSchema7Type;\n  required?: string[];\n};\n\nexport function parseObjectDef(def: ZodObjectDef, refs: Refs) {\n  const result: JsonSchema7ObjectType = {\n    type: 'object',\n    ...Object.entries(def.shape()).reduce(\n      (\n        acc: {\n          properties: Record<string, JsonSchema7Type>;\n          required: string[];\n        },\n        [propName, propDef],\n      ) => {\n        if (propDef === undefined || propDef._def === undefined) return acc;\n        const parsedDef = parseDef(propDef._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, 'properties', propName],\n          propertyPath: [...refs.currentPath, 'properties', propName],\n        });\n        if (parsedDef === undefined) return acc;\n        return {\n          properties: {\n            ...acc.properties,\n            [propName]: parsedDef,\n          },\n          required:\n            propDef.isOptional() && !refs.openaiStrictMode ? acc.required : [...acc.required, propName],\n        };\n      },\n      { properties: {}, required: [] },\n    ),\n    additionalProperties: decideAdditionalProperties(def, refs),\n  };\n  if (!result.required!.length) delete result.required;\n  return result;\n}\n","import { ZodOptionalDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport const parseOptionalDef = (def: ZodOptionalDef, refs: Refs): JsonSchema7Type | undefined => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'anyOf', '1'],\n  });\n\n  return innerSchema ?\n      {\n        anyOf: [\n          {\n            not: {},\n          },\n          innerSchema,\n        ],\n      }\n    : {};\n};\n","import { ZodPipelineDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7AllOfType } from './intersection';\n\nexport const parsePipelineDef = (\n  def: ZodPipelineDef<any, any>,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined => {\n  if (refs.pipeStrategy === 'input') {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === 'output') {\n    return parseDef(def.out._def, refs);\n  }\n\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', '0'],\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', a ? '1' : '0'],\n  });\n\n  return {\n    allOf: [a, b].filter((x): x is JsonSchema7Type => x !== undefined),\n  };\n};\n","import { ZodPromiseDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport function parsePromiseDef(def: ZodPromiseDef, refs: Refs): JsonSchema7Type | undefined {\n  return parseDef(def.type._def, refs);\n}\n","import { ZodSetDef } from 'zod';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport type JsonSchema7SetType = {\n  type: 'array';\n  uniqueItems: true;\n  items?: JsonSchema7Type | undefined;\n  minItems?: number;\n  maxItems?: number;\n  errorMessage?: ErrorMessages<JsonSchema7SetType>;\n};\n\nexport function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'items'],\n  });\n\n  const schema: JsonSchema7SetType = {\n    type: 'array',\n    uniqueItems: true,\n    items,\n  };\n\n  if (def.minSize) {\n    setResponseValueAndErrors(schema, 'minItems', def.minSize.value, def.minSize.message, refs);\n  }\n\n  if (def.maxSize) {\n    setResponseValueAndErrors(schema, 'maxItems', def.maxSize.value, def.maxSize.message, refs);\n  }\n\n  return schema;\n}\n","import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport type JsonSchema7TupleType = {\n  type: 'array';\n  minItems: number;\n  items: JsonSchema7Type[];\n} & (\n  | {\n      maxItems: number;\n    }\n  | {\n      additionalItems?: JsonSchema7Type | undefined;\n    }\n);\n\nexport function parseTupleDef(\n  def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>,\n  refs: Refs,\n): JsonSchema7TupleType {\n  if (def.rest) {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce((acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]), []),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, 'additionalItems'],\n      }),\n    };\n  } else {\n    return {\n      type: 'array',\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, 'items', `${i}`],\n          }),\n        )\n        .reduce((acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]), []),\n    };\n  }\n}\n","export type JsonSchema7UndefinedType = {\n  not: {};\n};\n\nexport function parseUndefinedDef(): JsonSchema7UndefinedType {\n  return {\n    not: {},\n  };\n}\n","export type JsonSchema7UnknownType = {};\n\nexport function parseUnknownDef(): JsonSchema7UnknownType {\n  return {};\n}\n","import { ZodReadonlyDef } from 'zod';\nimport { parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\n\nexport const parseReadonlyDef = (def: ZodReadonlyDef<any>, refs: Refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n","import { ZodSchema } from 'zod';\nimport { Options, Targets } from './Options';\nimport { JsonSchema7Type, parseDef } from './parseDef';\nimport { getRefs } from './Refs';\nimport { zodDef, isEmptyObj } from './util';\n\nconst zodToJsonSchema = <Target extends Targets = 'jsonSchema7'>(\n  schema: ZodSchema<any>,\n  options?: Partial<Options<Target>> | string,\n): (Target extends 'jsonSchema7' ? JsonSchema7Type : object) & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: Target extends 'jsonSchema7' ? JsonSchema7Type\n    : Target extends 'jsonSchema2019-09' ? JsonSchema7Type\n    : object;\n  };\n} => {\n  const refs = getRefs(options);\n\n  const name =\n    typeof options === 'string' ? options\n    : options?.nameStrategy === 'title' ? undefined\n    : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined ? refs : (\n        {\n          ...refs,\n          currentPath: [...refs.basePath, refs.definitionPath, name],\n        }\n      ),\n      false,\n    ) ?? {};\n\n  const title =\n    typeof options === 'object' && options.name !== undefined && options.nameStrategy === 'title' ?\n      options.name\n    : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  const definitions = (() => {\n    if (isEmptyObj(refs.definitions)) {\n      return undefined;\n    }\n\n    const definitions: Record<string, any> = {};\n    const processedDefinitions = new Set();\n\n    // the call to `parseDef()` here might itself add more entries to `.definitions`\n    // so we need to continually evaluate definitions until we've resolved all of them\n    //\n    // we have a generous iteration limit here to avoid blowing up the stack if there\n    // are any bugs that would otherwise result in us iterating indefinitely\n    for (let i = 0; i < 500; i++) {\n      const newDefinitions = Object.entries(refs.definitions).filter(\n        ([key]) => !processedDefinitions.has(key),\n      );\n      if (newDefinitions.length === 0) break;\n\n      for (const [key, schema] of newDefinitions) {\n        definitions[key] =\n          parseDef(\n            zodDef(schema),\n            { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] },\n            true,\n          ) ?? {};\n        processedDefinitions.add(key);\n      }\n    }\n\n    return definitions;\n  })();\n\n  const combined: ReturnType<typeof zodToJsonSchema<Target>> =\n    name === undefined ?\n      definitions ?\n        {\n          ...main,\n          [refs.definitionPath]: definitions,\n        }\n      : main\n    : refs.nameStrategy === 'duplicate-ref' ?\n      {\n        ...main,\n        ...(definitions || refs.seenRefs.size ?\n          {\n            [refs.definitionPath]: {\n              ...definitions,\n              // only actually duplicate the schema definition if it was ever referenced\n              // otherwise the duplication is completely pointless\n              ...(refs.seenRefs.size ? { [name]: main } : undefined),\n            },\n          }\n        : undefined),\n      }\n    : {\n        $ref: [...(refs.$refStrategy === 'relative' ? [] : refs.basePath), refs.definitionPath, name].join(\n          '/',\n        ),\n        [refs.definitionPath]: {\n          ...definitions,\n          [name]: main,\n        },\n      };\n\n  if (refs.target === 'jsonSchema7') {\n    combined.$schema = 'http://json-schema.org/draft-07/schema#';\n  } else if (refs.target === 'jsonSchema2019-09') {\n    combined.$schema = 'https://json-schema.org/draft/2019-09/schema#';\n  }\n\n  return combined;\n};\n\nexport { zodToJsonSchema };\n"],"mappings":"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","names":["import_zod","import_zod","types","x","base","definitions","schema"]}